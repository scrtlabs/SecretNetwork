use core::{mem, slice};

use base64ct::Encoding;
use enclave_crypto::dcap::verify_quote_any;
use serde_json::Value;
use sha2::Sha256;
use std::collections::{HashMap, HashSet};
use std::convert::TryFrom;
use std::io::Write;
use std::untrusted::fs::File;
use std::vec::Vec;

use log::*;
use rsa::signature::Verifier;

#[cfg(feature = "SGX_MODE_HW")]
use sgx_tse::rsgx_create_report;

#[cfg(feature = "SGX_MODE_HW")]
use sgx_types::{
    sgx_ql_auth_data_t, sgx_ql_certification_data_t, sgx_ql_ecdsa_sig_data_t, sgx_ql_qv_result_t,
    sgx_quote_t, sgx_report_body_t, sgx_status_t,
};

#[cfg(feature = "SGX_MODE_HW")]
use sgx_types::{sgx_report_data_t, sgx_report_t, sgx_target_info_t};

#[cfg(feature = "SGX_MODE_HW")]
use std::{str, string::String};

#[cfg(all(feature = "SGX_MODE_HW", feature = "production"))]
use crate::registration::offchain::get_attestation_report_dcap;

#[cfg(all(feature = "SGX_MODE_HW", feature = "production"))]
use enclave_crypto::consts::*;

#[cfg(all(feature = "SGX_MODE_HW", feature = "production"))]
use std::sgxfs::remove as SgxFsRemove;

#[cfg(feature = "SGX_MODE_HW")]
use super::ocalls::{
    ocall_get_quote_ecdsa, ocall_get_quote_ecdsa_collateral, ocall_get_quote_ecdsa_params,
};

#[cfg(feature = "SGX_MODE_HW")]
use ::hex as orig_hex;

#[cfg(all(feature = "SGX_MODE_HW", feature = "production"))]
pub fn validate_enclave_version(kp: &enclave_crypto::KeyPair) -> Result<(), sgx_status_t> {
    let res_dcap = unsafe { get_attestation_report_dcap(&kp.get_pubkey()) };

    match res_dcap {
        Ok(_) => Ok(()),
        Err(e) => Err(e),
    }
}

#[cfg(all(feature = "SGX_MODE_HW", feature = "production"))]
fn remove_secret_file(file_name: &str) {
    let _ = SgxFsRemove(make_sgx_secret_path(file_name));
}

#[cfg(all(feature = "SGX_MODE_HW", feature = "production"))]
#[allow(dead_code)]
fn remove_all_keys() {
    remove_secret_file(&SEALED_FILE_UNITED);
    remove_secret_file(SEALED_FILE_REGISTRATION_KEY);
    remove_secret_file(SEALED_FILE_ENCRYPTED_SEED_KEY_GENESIS);
    remove_secret_file(SEALED_FILE_ENCRYPTED_SEED_KEY_CURRENT);
    remove_secret_file(SEALED_FILE_IRS);
    remove_secret_file(SEALED_FILE_REK);
    remove_secret_file(SEALED_FILE_TX_BYTES);
}

#[cfg(feature = "SGX_MODE_HW")]
#[allow(dead_code)]
pub fn in_grace_period(timestamp: u64) -> bool {
    // Friday, August 21, 2023 2:00:00 PM UTC
    timestamp < 1692626400_u64
}

pub struct KnownJwtKeys {
    pub coll: HashMap<Vec<u8>, rsa::pkcs1v15::VerifyingKey<Sha256>>,
}

fn my_decode_base64(enc: &str) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
    match base64ct::Base64UrlUnpadded::decode_vec(enc) {
        Ok(x) => Ok(x),
        Err(e) => Err(format!("base64 decode failed: {:?}", e).into()),
    }
}

impl KnownJwtKeys {
    fn add_key(
        &mut self,
        kid_b64: &str,
        n_b64: &str,
        e_b64: &str,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let kid_bytes = base64::decode(kid_b64)?;
        let n_bytes = my_decode_base64(n_b64)?;
        let e_bytes = my_decode_base64(e_b64)?;

        // 2️⃣ Construct RSA public key
        let n = rsa::BigUint::from_bytes_be(&n_bytes);
        let e = rsa::BigUint::from_bytes_be(&e_bytes);
        let pubkey = rsa::RsaPublicKey::new(n, e).map_err(|_| "invalid RSA key components")?;

        let verifying_key = rsa::pkcs1v15::VerifyingKey::<Sha256>::new(pubkey);
        self.coll.insert(kid_bytes, verifying_key);

        Ok(())
    }
}

lazy_static::lazy_static! {

    static ref KNOWN_JWT_KEYS: KnownJwtKeys  = {
        let mut keys = KnownJwtKeys {
            coll: HashMap::new()
        };

        keys.add_key("J0pAPdfXXHqWWimgrH853wMIdh5/fLe1z6uSXYPXCa0=", "2NBrEQdwXUzVy2p-SZ7sBjxbVd4iTGNEQJu_Ot_C0NCzXIDT6DMEAeVZLSoWWcW6oXQ81h-yQWtw-jFW_SPgG4FGSL1UnVO8Zak80thovQk0dbZDo-9lsoOnOfXfPUL0T9AgHtqJpUr3tCfyRRLdC0MgF1tAyjZbMj8bHe2ZmJ9GLTJT5v9E0i5l3S4WZY52vMzZaVpfxw-0_s5tRzcoPGqIrMOnX_7kv5j7sisqZKNq6fP-4MHvLb_tXyHCkW6FzX8mUlwyRNzBP3R4xaXBvykzJMaAiCW_Yr_TxycdnmwsTR7he1Q78q12KnYqLvUVjg_v39_RWGSbFnaP1YX5Hw", "AQAB").unwrap();
        keys.add_key("ZOub53V4dZuruzP0dOOH0axfyks=", "svsohLQjA_aPyQ7EE9ZJYNYtNZ3QlFDMlVBNjurKl1r3WlM9089GMP1oc6pirai20_MuBISvmd-RDH4vLelHEfS9GrMROG-B0OrdB5mB8XlcA9ErN2_ztsqlhG28m3LTsAhMf8guhFR2-78ukOVhH0lJYFtpG9wbE0aCoBxXpSVS7JR_Otadv00EskIUoZkjx0YX94NVE7-fHMS6DD4TWEOng17mNAKELJbwdHgA5DyQsFMW7mVJVK-1BHQ5m14wYWeLadEGnzVgrc1T_x2-VJrAbSai9_xhrbZ7-RsCCTuQs0az2akbQyfb-zlyywNPIl8JO8_9j4JL8zdWNBiRAQ", "AQAB").unwrap();
        keys.add_key("frVjcejaF7GhoPNgEN9FdDQp7/Iwlpl/Ug8/TMh/3eg=", "2WxgwBuJY-wZ_9rmTtxIHXzeqJc0qo72Ft6MYog9qY3K6ZgGmmii_pi1FvwQP43bgXyOALtbWzcmMp5gl3prnZeiNmnb_5bHys1C-0bBWO0z6NhpBevfbejmiBc63WuWl5ZEZF29hzkQyoHm-25NyYpqBtPw2469tvJoxhCng5u_tYLpI2qJljQazxyWcMj2LdTxr_LNBLPR5Naz8DgWPS5xEs3QTzoxzauA6G0PKRPdsIbWa-8ka5PPopdd41580t9j_mD6ia7muslk6D9a4g1VHlIcIA0Kv1CeWx1CLiMoEo1qE25f9qLc5HImZnhCmC25dP6PhEjS1rLaTOA_LQ", "AQAB").unwrap();

        keys
    };

    static ref PPID_WHITELIST: HashSet<[u8; 20]>  = {
        let mut set: HashSet<[u8; 20]> = HashSet::new();

        set.insert([0x01,0x50,0x7c,0x95,0x77,0x89,0xb7,0xc1,0xaf,0xde,0x97,0x2d,0x67,0xf1,0xfd,0xd5,0x3a,0xf1,0xa8,0xda]);
        set.insert([0x04,0xf0,0x14,0x07,0xb7,0x62,0xaf,0x16,0xdb,0x04,0xac,0x64,0x8a,0xee,0x5f,0xeb,0x24,0xcf,0x6e,0xb8]);
        set.insert([0x05,0x04,0x30,0x40,0x8a,0x4c,0xea,0xe5,0xd0,0xb9,0xd9,0x57,0x21,0xd6,0x51,0x22,0x2c,0xbd,0x83,0xd3]);
        set.insert([0x05,0x1f,0x83,0xeb,0x42,0xdf,0xdd,0x78,0x50,0x08,0x6c,0xf5,0x69,0x6f,0xbb,0x36,0x53,0xf8,0x83,0xae]);
        set.insert([0x09,0xe9,0x87,0x5e,0xd7,0xac,0xd4,0x2c,0x7d,0xd1,0x9d,0x72,0xa3,0x95,0x24,0xf6,0xae,0x3e,0x87,0xfa]);
        set.insert([0x11,0x21,0xe6,0xd9,0xa7,0x70,0xc9,0xe5,0x62,0xae,0x42,0x30,0x12,0x08,0x0e,0x52,0x76,0x5e,0xcf,0x71]);
        set.insert([0x13,0xf1,0x08,0xbd,0xf8,0xfd,0x3f,0x11,0xe7,0x50,0x26,0xd9,0x8e,0xd1,0x80,0x30,0x75,0x25,0x73,0x54]);
        set.insert([0x14,0xd1,0x23,0x60,0x33,0xfd,0xe3,0x1e,0x0b,0xcd,0x57,0x0c,0x32,0x91,0xea,0xa9,0xbd,0xb7,0xe2,0x5e]);
        set.insert([0x16,0x32,0xea,0x13,0x05,0x1c,0xc4,0xd3,0x92,0xcb,0x8d,0x3e,0x01,0x6e,0xb5,0x61,0x7d,0x8e,0x8b,0x2a]);
        set.insert([0x18,0x81,0x20,0xcd,0x27,0xf6,0x58,0xa7,0x29,0x2c,0x46,0x6f,0x6c,0x7d,0xf5,0xaf,0x6c,0xdb,0x96,0x6e]);
        set.insert([0x1a,0xe4,0xfb,0x51,0x62,0x6d,0x0d,0x27,0x4c,0x0b,0xd3,0x85,0x1e,0x5a,0x04,0xde,0xe0,0xb0,0xd5,0x3b]);
        set.insert([0x1b,0x3a,0xad,0xe4,0x41,0xad,0xd6,0x58,0xf9,0xf9,0x5c,0x10,0xce,0x0f,0x3d,0x75,0x4f,0x92,0xa3,0x27]);
        set.insert([0x1c,0x8b,0xe8,0x11,0xc0,0x91,0x85,0xa9,0xf6,0xc7,0xdc,0x3f,0xba,0x81,0xe8,0x78,0xa5,0x8d,0x0a,0x1b]);
        set.insert([0x20,0x59,0x8f,0xcb,0x4b,0xa5,0x79,0xc5,0xa0,0x9e,0x8c,0x1a,0x42,0xec,0x9c,0x02,0x10,0xcb,0x43,0xf3]);
        set.insert([0x21,0xca,0xe8,0x22,0x31,0x4c,0x17,0x72,0x16,0x77,0xc4,0x1c,0xd8,0x42,0x34,0x64,0x98,0x35,0x53,0xc1]);
        set.insert([0x22,0x1c,0xd8,0x23,0x4e,0x36,0x9e,0xf1,0x9d,0xfd,0xad,0x94,0xf4,0x37,0xd3,0xa1,0x90,0xcb,0x26,0x73]);
        set.insert([0x24,0x91,0xb9,0xa2,0x2f,0x4b,0x3d,0x45,0x82,0xaf,0x20,0x92,0x19,0x19,0xbc,0x27,0x71,0xc8,0x0f,0xde]);
        set.insert([0x26,0x67,0x1a,0x09,0x31,0xeb,0xde,0x25,0x27,0x37,0x36,0xbf,0x6b,0x4b,0x2e,0xd1,0x03,0x8c,0x44,0x43]);
        set.insert([0x28,0x04,0x9f,0x3f,0x69,0xf6,0x55,0x83,0x24,0xe5,0x2d,0x44,0xec,0xde,0xf8,0x97,0xb1,0xa3,0xb3,0x90]);
        set.insert([0x2a,0x00,0x3f,0x2b,0x90,0x8b,0x08,0x47,0x6b,0xe2,0x5d,0x01,0x1c,0x57,0xfe,0x11,0xfc,0x68,0x92,0xf9]);
        set.insert([0x30,0x7b,0xbc,0xfb,0x24,0xab,0xdb,0x94,0xa6,0xb7,0xca,0xba,0xdd,0xb9,0x19,0x04,0x64,0x03,0xff,0xe6]);
        set.insert([0x31,0x5d,0xb0,0x4d,0xf6,0x69,0x89,0x4a,0x3e,0x35,0x42,0x96,0x91,0xb8,0xb3,0x50,0xd8,0xcb,0xcd,0xe2]);
        set.insert([0x35,0x99,0xc4,0x8a,0x2a,0x1b,0xbf,0xf8,0x74,0xda,0xc4,0x6d,0x98,0x6a,0x51,0x2f,0x69,0xfb,0xc8,0xd0]);
        set.insert([0x36,0xa3,0x75,0x06,0xdc,0xc6,0x2a,0x21,0x53,0xae,0x3d,0xa7,0x41,0xf5,0x6a,0x01,0xbe,0xd5,0x42,0x67]);
        set.insert([0x3e,0x68,0x30,0xd6,0xa2,0xd8,0x39,0xbf,0x36,0xbb,0x10,0x8c,0xa8,0xcc,0xc2,0x5a,0x16,0x78,0xf8,0x2f]);
        set.insert([0x40,0x83,0x2a,0x64,0xb2,0x7c,0x12,0xc7,0xab,0xe6,0xbe,0x09,0x47,0x16,0x3e,0xe4,0x83,0x47,0x8c,0x61]);
        set.insert([0x41,0x01,0xa8,0x18,0x7d,0x20,0x88,0x9c,0x4f,0xd2,0x47,0xb4,0xc8,0x27,0x9b,0x66,0x31,0x8e,0xf0,0x91]);
        set.insert([0x42,0x26,0xd0,0x78,0x02,0x9b,0x9b,0xe4,0xf3,0x2a,0x61,0x5e,0x92,0x90,0xdb,0xcd,0xe3,0xd5,0x5f,0x76]);
        set.insert([0x44,0x3b,0x01,0xf0,0x77,0x19,0xd7,0xce,0x6c,0xbd,0xe8,0x61,0x08,0x2a,0x33,0x18,0x1b,0xb2,0x4e,0x4c]);
        set.insert([0x44,0xe1,0x05,0x97,0xb4,0x2e,0x57,0x14,0x23,0x91,0x53,0x85,0xfe,0x85,0xce,0xd0,0xe8,0x40,0x85,0x0c]);
        set.insert([0x46,0x1b,0xe5,0xde,0x74,0xce,0x83,0x3d,0x38,0x28,0xfc,0xb5,0x7c,0x24,0x3b,0x60,0x15,0xd7,0x6d,0x7f]);
        set.insert([0x48,0x82,0x28,0x89,0x4e,0x72,0x65,0xff,0x74,0xd9,0x74,0x95,0xd2,0xd5,0x36,0xb9,0xc7,0xf5,0x74,0x11]);
        set.insert([0x4a,0xf5,0xd9,0x4e,0x22,0x81,0xe2,0xa4,0xc2,0x3e,0xd8,0x4c,0x4a,0x05,0xaa,0x5e,0x7a,0x31,0x78,0xd2]);
        set.insert([0x4e,0x09,0x78,0x81,0x59,0x00,0x8f,0x91,0xd7,0xf3,0xd6,0x8b,0x1a,0xf2,0x35,0x5b,0x3c,0x17,0x72,0xcc]);
        set.insert([0x51,0xc1,0xed,0xe1,0x8e,0x73,0xfc,0x7e,0x00,0xe8,0xfc,0x01,0x8e,0xde,0x53,0x63,0x2f,0x8b,0xb6,0xd9]);
        set.insert([0x53,0x54,0x3f,0x1a,0x7d,0x08,0xc1,0x3d,0x69,0x38,0x5b,0x81,0x20,0x56,0x2a,0x76,0xb8,0x71,0xf8,0xec]);
        set.insert([0x57,0x19,0x8e,0xb3,0x6e,0x5c,0x99,0x68,0x63,0xb6,0x26,0xeb,0x6f,0x23,0xe3,0x87,0x7c,0xb2,0xed,0x17]);
        set.insert([0x57,0xa6,0x87,0x7d,0x0e,0x96,0xce,0x77,0xa3,0xfa,0xfb,0x0c,0x2f,0x7e,0x9e,0xd9,0xe2,0x8f,0xb0,0x37]);
        set.insert([0x5d,0x73,0xa5,0x89,0xb3,0x57,0xf4,0xe7,0xad,0x59,0x9b,0x4a,0x4a,0x7e,0x43,0x38,0xcd,0x73,0x30,0x18]);
        set.insert([0x67,0x44,0x97,0x91,0x8b,0x42,0x04,0xd3,0xe6,0x86,0xba,0x23,0x40,0x8a,0x9a,0xa2,0x16,0xb2,0x22,0x7a]);
        set.insert([0x68,0x92,0x8a,0xa2,0xc3,0x16,0x7d,0x75,0xd5,0x66,0xe5,0x4b,0x47,0x54,0x62,0xaa,0x28,0x72,0xcb,0x2f]);
        set.insert([0x6a,0x81,0xac,0x2a,0x32,0xcc,0x2e,0xac,0x4b,0x97,0x4b,0x18,0x19,0xed,0x2b,0x75,0x68,0xc8,0x3c,0x04]);
        set.insert([0x6c,0xe7,0x2a,0xa2,0x20,0x18,0x62,0x2c,0x24,0xa2,0xc0,0xaa,0xc4,0x5f,0x14,0x61,0x7a,0xec,0x59,0xe5]);
        set.insert([0x74,0x02,0xb6,0x3c,0x09,0xf3,0x52,0x09,0x31,0xda,0xc2,0xf9,0xf7,0x02,0xce,0x16,0x50,0x3d,0x36,0x48]);
        set.insert([0x78,0x27,0x70,0x25,0x3c,0x0a,0xe7,0x2e,0xdd,0x91,0x13,0x8a,0xd0,0x01,0x7c,0xdb,0x9a,0x7d,0x8d,0xba]);
        set.insert([0x79,0x17,0x73,0xaa,0x0b,0x8a,0xe2,0xdc,0x8c,0xb7,0x5e,0xb9,0xd5,0x64,0xa0,0xd5,0x98,0x12,0x55,0x72]);
        set.insert([0x7a,0x89,0xc9,0xdd,0x73,0x83,0xdd,0xe2,0x74,0x19,0xb3,0x6e,0x2c,0x6d,0x0d,0x94,0x2e,0xee,0x85,0xd9]);
        set.insert([0x80,0xfc,0xb4,0xf6,0xf0,0x86,0xe6,0xbb,0xd8,0x32,0x50,0x0c,0x2b,0x72,0x9c,0x26,0xb3,0xbf,0x1a,0xd2]);
        set.insert([0x81,0x3b,0xf8,0x20,0xfd,0x54,0x35,0xd0,0x3d,0xb7,0xbb,0xeb,0x04,0xd2,0xc3,0x42,0x17,0xf2,0xf9,0x49]);
        set.insert([0x84,0xca,0x01,0x28,0x46,0x31,0x54,0x15,0x12,0x65,0x21,0xd8,0xaf,0xdf,0x5d,0xda,0x5f,0x77,0x53,0x06]);
        set.insert([0x8f,0x06,0xc7,0xf4,0xf5,0xf8,0x68,0x42,0xae,0xe7,0x84,0x33,0x70,0x21,0xeb,0xd5,0x9d,0x4a,0xf9,0xf1]);
        set.insert([0x8f,0xc9,0x82,0x1d,0xbf,0xa8,0x3b,0x21,0x7f,0x8f,0x61,0xf1,0xf4,0x1f,0x05,0x74,0x25,0xdc,0xd3,0xb6]);
        set.insert([0x8f,0xfb,0xc5,0xef,0x59,0xef,0x9f,0x22,0x89,0xe7,0x4a,0x37,0x45,0x03,0x9d,0x90,0x0f,0xba,0x30,0xfe]);
        set.insert([0x90,0x48,0xc1,0x42,0xde,0x1f,0xe7,0x0d,0x3e,0xf4,0xa9,0x10,0x7c,0xcf,0xbe,0x23,0x5d,0xf5,0x36,0xc0]);
        set.insert([0x93,0xbd,0x0a,0x2c,0x4b,0x01,0xd3,0xfb,0x0f,0x21,0xb0,0x72,0xc0,0x4f,0xee,0xea,0x7e,0x64,0x9a,0xe2]);
        set.insert([0x97,0x58,0x7e,0x41,0x8d,0xc1,0xaf,0xbc,0xa9,0x93,0x9c,0x06,0xcc,0xb9,0x7f,0x31,0x15,0xc5,0x8c,0x65]);
        set.insert([0x98,0xcb,0x37,0x1d,0x43,0x68,0x2e,0xb8,0x7d,0x6f,0xb1,0xac,0x1c,0x95,0x89,0xd7,0x9f,0xcd,0x69,0xce]);
        set.insert([0x9a,0xce,0x47,0xea,0xcb,0xe6,0xab,0x51,0x12,0xbd,0x6d,0x8e,0xbc,0x55,0x5b,0x0f,0xef,0x9f,0x23,0x32]);
        set.insert([0x9c,0x80,0xbc,0x6b,0xf4,0x58,0x6e,0xdb,0x26,0x89,0xc3,0x09,0x3a,0x9a,0x0a,0xec,0xa3,0x01,0x48,0x05]);
        set.insert([0x9d,0x08,0x17,0x1e,0xc1,0xca,0xe6,0xce,0x1e,0xa0,0xce,0x3f,0x36,0x74,0xfa,0x5d,0x01,0xf6,0xf1,0xb3]);
        set.insert([0x9e,0xbd,0x6f,0x9e,0x55,0x0f,0x0d,0x6d,0xd0,0x0d,0xe5,0x25,0x5f,0x03,0xde,0xd6,0x1e,0x17,0xe2,0xc7]);
        set.insert([0xa0,0x2f,0x25,0xaf,0xce,0x5e,0xea,0xb3,0x21,0xa4,0xe7,0x69,0x43,0xe5,0x6d,0x6e,0x9a,0xa7,0x3f,0xe4]);
        set.insert([0xa0,0x41,0x7d,0x62,0x7d,0x22,0x5e,0x21,0x54,0x3c,0xf9,0xa9,0x1b,0x2d,0x83,0xb9,0x5f,0x09,0x1d,0xc6]);
        set.insert([0xa4,0x0b,0x94,0x76,0xfb,0x30,0x5c,0x1d,0x39,0x75,0x2f,0xd4,0x85,0x48,0xc5,0xfa,0x3c,0x37,0x15,0x71]);
        set.insert([0xa4,0x68,0x49,0x55,0x2c,0x73,0x63,0x28,0x5b,0xae,0xdb,0x5a,0x6b,0x68,0x14,0x80,0x9a,0x59,0xed,0x92]);
        set.insert([0xa6,0xad,0xab,0xb2,0xa2,0x5d,0x23,0x3c,0x62,0xaf,0xd1,0xfc,0x0e,0x99,0x1d,0x25,0x13,0xdc,0x11,0xd4]);
        set.insert([0xac,0x47,0xf3,0x11,0x51,0x09,0xba,0xeb,0x98,0xde,0xaf,0xdc,0xbd,0x98,0x01,0x17,0xb4,0xe2,0x86,0xba]);
        set.insert([0xaf,0x15,0x78,0xfb,0xef,0x76,0x67,0x2f,0xef,0x3b,0x92,0x50,0xb3,0x0c,0xef,0x40,0x7e,0x78,0xfd,0x26]);
        set.insert([0xb2,0xed,0x08,0x99,0x4a,0xe4,0xd6,0xdb,0x46,0xb3,0x16,0xd3,0x84,0x38,0x0f,0x69,0x63,0x64,0x04,0xfa]);
        set.insert([0xb3,0xc0,0xa1,0x40,0x68,0x94,0xe9,0x31,0x96,0x1e,0x0f,0xe3,0x4a,0x68,0xbd,0x01,0x48,0x33,0x7e,0x58]);
        set.insert([0xb4,0xcd,0xc2,0xe6,0x62,0x0d,0xfd,0x8c,0x5d,0x56,0x50,0x41,0x28,0x47,0x14,0xc3,0x80,0x79,0xc7,0x4c]);
        set.insert([0xb7,0xed,0x7f,0x4a,0x12,0x88,0xc9,0x8c,0x49,0xb4,0x6a,0x6a,0xf8,0x56,0x53,0x2e,0x65,0xea,0xed,0xab]);
        set.insert([0xbb,0x98,0x12,0x7d,0x89,0xb2,0xe3,0xf4,0xf9,0xdb,0x41,0x0b,0x06,0x0e,0x0a,0xff,0xa4,0x8e,0x07,0xef]);
        set.insert([0xbb,0xed,0x9a,0xc0,0xc3,0xb9,0x20,0x3d,0x4d,0xa1,0x9c,0xab,0x34,0xfb,0xfb,0x8c,0xe6,0xa4,0x41,0x1c]);
        set.insert([0xc1,0x33,0xf0,0xc3,0x75,0x1a,0x90,0x85,0x84,0xdc,0xdf,0x32,0x2d,0x72,0xb5,0x17,0x7c,0x12,0xe7,0x32]);
        set.insert([0xc2,0xf7,0xf3,0xb6,0x0a,0xcd,0xe8,0xdd,0xff,0x16,0x71,0x04,0xc5,0x6e,0x1e,0xd5,0xa1,0xe3,0xeb,0x74]);
        set.insert([0xc3,0x10,0x8f,0xa4,0x05,0xef,0x44,0xa7,0x1a,0x5d,0x88,0x03,0x21,0xe0,0x9a,0x62,0x0f,0x7f,0x4f,0x76]);
        set.insert([0xc3,0x1a,0x7d,0x5c,0x50,0x80,0xd9,0x0a,0x62,0x0d,0x36,0x48,0x54,0xba,0x33,0x6d,0xc8,0x2c,0xb2,0xc1]);
        set.insert([0xc4,0xad,0x39,0x80,0xab,0x87,0x72,0xd4,0xd6,0x3b,0x0a,0x7f,0x51,0xba,0xdf,0x00,0x65,0xdc,0x09,0x5a]);
        set.insert([0xc4,0xc1,0x07,0x66,0xc4,0x48,0x9b,0x71,0x77,0xcf,0x5a,0x21,0xa0,0xdc,0x48,0xe6,0x89,0x99,0x9a,0xe8]);
        set.insert([0xc4,0xc2,0xef,0x79,0x5e,0x37,0x11,0x16,0xee,0xa7,0xfe,0x8b,0x98,0x1e,0x38,0xb7,0xe0,0xcf,0x10,0x17]);
        set.insert([0xc6,0x45,0xec,0xce,0xbc,0x5a,0xa8,0x19,0x3b,0x4b,0xe8,0x5c,0x71,0xec,0x55,0x0f,0x6e,0x0b,0xf6,0xe9]);
        set.insert([0xc6,0x65,0x51,0xe2,0xc5,0x57,0x6b,0x91,0xe2,0x95,0x4d,0xca,0x76,0x79,0xa9,0x26,0x65,0xf5,0x89,0x4c]);
        set.insert([0xc8,0x63,0x8d,0xc5,0xe9,0x29,0x33,0x70,0x9f,0x64,0x7c,0xa7,0xab,0x78,0xee,0xb3,0x9d,0x39,0x95,0x75]);
        set.insert([0xcb,0xfd,0xda,0x92,0x33,0x07,0xf8,0xab,0x91,0x89,0x71,0x31,0xb6,0x13,0xb7,0xd8,0xe7,0xd6,0x22,0xe2]);
        set.insert([0xcd,0xd1,0x28,0x05,0x6d,0x8f,0x6b,0xb1,0xcb,0x31,0x17,0xf3,0x7f,0x0a,0xea,0xdc,0x1a,0x51,0xf2,0x9b]);
        set.insert([0xce,0x8a,0x5c,0x63,0x01,0xb1,0x8a,0xac,0xde,0x48,0xff,0x4c,0x83,0x8b,0x59,0xe3,0x87,0x63,0xe6,0x05]);
        set.insert([0xd0,0xc4,0x65,0x7e,0xb4,0x0a,0xdc,0x66,0x23,0x78,0xad,0x0b,0x6b,0x25,0x13,0xc6,0x13,0x8e,0xf5,0x51]);
        set.insert([0xd2,0x9e,0x7c,0x5a,0x8b,0x1c,0xbd,0xf6,0x36,0x29,0xf0,0x86,0x28,0x93,0xa8,0xf8,0x90,0x77,0xb4,0x1a]);
        set.insert([0xd7,0x54,0xcb,0xa1,0x3f,0xc2,0xe3,0x7b,0x0b,0x8f,0x92,0x10,0x65,0x21,0x45,0x0c,0x78,0x24,0xe8,0x5a]);
        set.insert([0xd7,0xda,0x52,0x0c,0xcc,0x85,0xd5,0x6c,0x19,0x25,0x6f,0xe6,0x78,0x52,0xe8,0x7a,0x3d,0x09,0x9d,0xe6]);
        set.insert([0xd9,0x63,0xe8,0x1a,0xcf,0x29,0x1c,0x7a,0xee,0xb5,0xfa,0x0f,0xf6,0x15,0x91,0xef,0xb8,0x6d,0x30,0xd2]);
        set.insert([0xdb,0x76,0x94,0xa4,0x75,0xe9,0xd6,0xaf,0x40,0x09,0xb6,0x0c,0x4b,0xe0,0xec,0x87,0xad,0x1a,0x6e,0xc6]);
        set.insert([0xdd,0x14,0xdb,0x55,0xa2,0x49,0x43,0x8d,0x2e,0xc6,0xd1,0xbe,0x1f,0x7c,0x1d,0x57,0x96,0x6b,0x9a,0xe8]);
        set.insert([0xdf,0x25,0xed,0x09,0xfc,0xa7,0x7a,0x19,0xd8,0x86,0xad,0x4f,0x2b,0xca,0x26,0x63,0xc0,0xa5,0xc1,0x13]);
        set.insert([0xe0,0xae,0x16,0xc0,0x87,0x51,0x05,0xd0,0xde,0x9c,0xa5,0xfe,0x53,0xa9,0x4c,0x93,0xa4,0x01,0xc9,0xb1]);
        set.insert([0xe0,0xd1,0x22,0xf6,0x11,0xe3,0x79,0x5b,0x28,0xa2,0x41,0x57,0xa9,0xc0,0x10,0x8b,0xca,0x57,0x92,0xf4]);
        set.insert([0xe2,0x55,0x63,0x2d,0xa8,0xcb,0x96,0x8a,0x9b,0x8a,0x7c,0xcc,0xb6,0xcf,0x02,0x0c,0xce,0xca,0xfe,0x22]);
        set.insert([0xe3,0x5a,0x36,0xf5,0xa1,0xee,0x2b,0xa8,0xfc,0x85,0x69,0x05,0x29,0x9c,0x84,0xf7,0x5b,0x61,0xe8,0x30]);
        set.insert([0xe5,0x71,0x83,0xd0,0xf0,0x63,0x54,0x86,0x89,0xc5,0xa1,0x4d,0x3b,0x72,0xd8,0x77,0x12,0x14,0x41,0xf1]);
        set.insert([0xe6,0x80,0x2c,0xc0,0x7c,0xa9,0xdc,0xc9,0x1e,0xde,0xa1,0xd5,0xa8,0x8a,0x59,0xa2,0x01,0x09,0x06,0x11]);
        set.insert([0xe8,0xbf,0x93,0x90,0xba,0x54,0xcd,0x80,0x00,0x13,0x08,0xc6,0xe2,0x57,0xac,0x77,0xd0,0x3c,0x61,0x8c]);
        set.insert([0xed,0xbe,0x8c,0xf5,0x9a,0x64,0x2b,0xac,0xd1,0x89,0xe4,0xe0,0x05,0x62,0xdf,0xab,0xae,0xfd,0x11,0x20]);
        set.insert([0xf0,0x2c,0x4e,0xef,0x50,0xb2,0xb4,0x66,0x0d,0x29,0x1c,0x81,0x36,0xa8,0x46,0x34,0x2f,0x79,0x0b,0x9d]);
        set.insert([0xf2,0x28,0xe8,0xbb,0x0a,0xea,0x2e,0x37,0x06,0x6f,0x93,0xdb,0x5c,0xbf,0xd9,0x34,0x2d,0x8f,0xff,0x0d]);
        set.insert([0xf4,0xe1,0x2f,0x72,0xac,0xcd,0xc8,0x3e,0xa3,0xe1,0x6b,0x73,0x07,0x79,0x69,0x0b,0x4a,0x9e,0x0b,0xed]);
        set.insert([0xf8,0xe6,0x1a,0x4a,0x80,0xc7,0x70,0x28,0xbe,0xb3,0x3a,0xe4,0xc4,0x6e,0x69,0xe6,0xf4,0x90,0x4e,0x61]);
        set.insert([0xf9,0x63,0xa2,0xbd,0x05,0x71,0x6c,0x42,0x9d,0x66,0x64,0x7b,0x6e,0xf1,0x53,0x87,0x47,0xcc,0xe5,0x5c]);
        set.insert([0xfc,0x2c,0x11,0xc9,0x5a,0x5a,0xad,0xfd,0x35,0x00,0x89,0x1e,0xce,0x06,0x65,0x1c,0x0b,0x4e,0xe0,0xe5]);
        set.insert([0xfe,0xc9,0x34,0x2e,0x9e,0xe4,0x18,0x64,0x53,0xf8,0xa7,0xe0,0x27,0xfa,0xc8,0xc2,0x4e,0x7c,0x0c,0x60]);


        set
    };

    static ref FMSPC_EOL: HashSet<&'static str> = HashSet::from([
        "00706A100000",
        "00706A800000",
        "00706E470000",
        "00806EA60000",
        "00806EB70000",
        "00906EA10000",
        "00906EA50000",
        "00906EB10000",
        "00906EC10000",
        "00906EC50000",
        "00906ED50000",
        "00A065510000",
        "20806EB70000",
        "20906EC10000",
    ]);
}

unsafe fn extract_fmspc_from_collateral(vec_coll: &[u8]) -> Option<String> {
    struct CollHdr {
        sizes: [u32; 8],
    }
    let i_tcb_idx = 5;

    let my_p_hdr = vec_coll.as_ptr() as *const CollHdr;

    let mut size0: u64 = mem::size_of::<CollHdr>() as u64;
    for i in 0..i_tcb_idx {
        size0 += (*my_p_hdr).sizes[i] as u64;
    }

    let size_tcb_info = (*my_p_hdr).sizes[i_tcb_idx];
    let size1 = size0 + size_tcb_info as u64;

    if (size1 > size0) && (size1 <= vec_coll.len() as u64) {
        let sub_slice = &vec_coll[size0 as usize..(size1 - 1) as usize];

        let my_val: Result<serde_json::Value, _> = serde_json::from_slice(sub_slice);
        if let Ok(json_val) = my_val {
            // Navigate to fmspc
            let fmspc = &json_val["tcbInfo"]["fmspc"];
            if let Some(fmspc_str) = fmspc.as_str() {
                return Some(fmspc_str.to_string());
            }
        }
    }

    None
}

pub struct AttestationCombined {
    pub quote: Vec<u8>,
    pub coll: Vec<u8>,
    pub jwt_token: Vec<u8>,
}

impl AttestationCombined {
    pub fn from_blob(blob_ptr: *const u8, blob_len: usize) -> AttestationCombined {
        let mut res = AttestationCombined {
            quote: Vec::new(),
            coll: Vec::new(),
            jwt_token: Vec::new(),
        };

        if (blob_len > 0) && (unsafe { *blob_ptr } != 0) {
            // try to deserialize in a newer format
            let mut pos = 0;
            while pos + mem::size_of::<u32>() < blob_len {
                let key = unsafe { *(blob_ptr.offset(pos as isize)) };
                pos += 1;

                let value_size =
                    u32::from_le(unsafe { *(blob_ptr.offset(pos as isize) as *const u32) })
                        as usize;
                pos += mem::size_of::<u32>();

                if pos + value_size > blob_len {
                    break;
                }

                let value =
                    unsafe { slice::from_raw_parts(blob_ptr.offset(pos as isize), value_size) };
                pos += value_size;

                match key {
                    2 => res.quote = value.to_vec(),
                    3 => res.coll = value.to_vec(),
                    4 => res.jwt_token = value.to_vec(),
                    _ => {}
                };
            }
        } else {
            // legacy
            let n0 = mem::size_of::<u32>() as u32 * 3;

            if blob_len >= n0 as usize {
                let p_blob = blob_ptr as *const u32;
                let s0 = u32::from_le(unsafe { *p_blob });
                let s1 = u32::from_le(unsafe { *(p_blob.offset(1)) });
                let s2 = u32::from_le(unsafe { *(p_blob.offset(2)) });

                let size_total = (n0 as u64) + (s0 as u64) + (s1 as u64) + (s2 as u64);

                if size_total <= blob_len as u64 {
                    //res.epid_quote =
                    //    unsafe { slice::from_raw_parts(blob_ptr.offset(n0 as isize), s0 as usize).to_vec() };
                    res.quote = unsafe {
                        slice::from_raw_parts(blob_ptr.offset((n0 + s0) as isize), s1 as usize)
                            .to_vec()
                    };
                    res.coll = unsafe {
                        slice::from_raw_parts(blob_ptr.offset((n0 + s0 + s1) as isize), s2 as usize)
                            .to_vec()
                    };
                }
            }
        }

        res
    }

    pub fn save(&self, f_out: &mut File) {
        let is_legacy = true;

        if is_legacy {
            let size_epid: u32 = 0;
            let size_dcap_q = self.quote.len() as u32;
            let size_dcap_c = self.coll.len() as u32;

            f_out.write_all(&size_epid.to_le_bytes()).unwrap();
            f_out.write_all(&size_dcap_q.to_le_bytes()).unwrap();
            f_out.write_all(&size_dcap_c.to_le_bytes()).unwrap();

            f_out.write_all(&self.quote).unwrap();
            f_out.write_all(&self.coll).unwrap();
        } else {
            Self::write_section(f_out, 2, &self.quote);
            Self::write_section(f_out, 3, &self.coll);
        }
    }

    fn write_section(f_out: &mut File, key: u8, value: &[u8]) {
        f_out.write_all(&key.to_le_bytes()).unwrap();

        let len = value.len() as u32;
        f_out.write_all(&len.to_le_bytes()).unwrap();

        f_out.write_all(value).unwrap();
    }

    pub unsafe fn extract_cpu_cert(&self) -> Option<Vec<u8>> {
        let my_p_quote = self.quote.as_ptr() as *const sgx_quote_t;

        let sig_len = (*my_p_quote).signature_len as usize;
        let whole_len = sig_len.wrapping_add(mem::size_of::<sgx_quote_t>());
        if (whole_len > sig_len)
            && (whole_len <= self.quote.len())
            && (sig_len >= mem::size_of::<sgx_ql_ecdsa_sig_data_t>())
        {
            let p_ecdsa_sig = (*my_p_quote).signature.as_ptr() as *const sgx_ql_ecdsa_sig_data_t;

            let auth_size_brutto = sig_len - mem::size_of::<sgx_ql_ecdsa_sig_data_t>();
            if auth_size_brutto >= mem::size_of::<sgx_ql_auth_data_t>() {
                let auth_size_max = auth_size_brutto - mem::size_of::<sgx_ql_auth_data_t>();

                let auth_data_wrapper =
                    (*p_ecdsa_sig).auth_certification_data.as_ptr() as *const sgx_ql_auth_data_t;

                let auth_hdr_size = (*auth_data_wrapper).size as usize;
                if auth_hdr_size <= auth_size_max {
                    let auth_size = auth_size_max - auth_hdr_size;

                    if auth_size > mem::size_of::<sgx_ql_certification_data_t>() {
                        let cert_data = (*auth_data_wrapper)
                            .auth_data
                            .as_ptr()
                            .offset(auth_hdr_size as isize)
                            as *const sgx_ql_certification_data_t;

                        let cert_size_max =
                            auth_size - mem::size_of::<sgx_ql_certification_data_t>();
                        let cert_size = (*cert_data).size as usize;
                        if (cert_size <= cert_size_max) && ((*cert_data).cert_key_type == 5) {
                            let cert_data = slice::from_raw_parts(
                                (*cert_data).certification_data.as_ptr(),
                                cert_size,
                            );

                            return Self::extract_cpu_cert_raw(cert_data);
                        }
                    }
                }
            }
        }

        None
    }

    fn extract_cpu_cert_raw(cert_data: &[u8]) -> Option<Vec<u8>> {
        let pem_text = match std::str::from_utf8(cert_data) {
            Ok(x) => x,
            Err(_) => {
                return None;
            }
        };

        // Find the first PEM block
        let begin_marker = "-----BEGIN CERTIFICATE-----";
        let end_marker = "-----END CERTIFICATE-----";
        let start = match pem_text.find(begin_marker) {
            Some(x) => x + begin_marker.len(),
            None => {
                println!("no begin");
                return None;
            }
        };

        let end = match pem_text.find(end_marker) {
            Some(x) => x,
            None => {
                println!("no end");
                return None;
            }
        };
        let b64 = &pem_text[start..end];

        // Remove whitespace and line breaks
        let b64_clean: String = b64.chars().filter(|c| !c.is_whitespace()).collect();

        // Decode Base64 into DER
        let der_bytes = match base64::decode(&b64_clean) {
            Ok(x) => x,
            Err(_) => {
                return None;
            }
        };

        let ppid_oid = &[
            0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF8, 0x4D, 0x01, 0x0D, 0x01,
        ];

        let res = match crate::registration::cert::extract_asn1_value(&der_bytes, ppid_oid) {
            Ok(x) => x,
            Err(_) => {
                return None;
            }
        };

        Some(res)
    }

    pub unsafe fn verify_fmspc(&self) -> bool {
        if let Some(fmspc) = extract_fmspc_from_collateral(&self.coll) {
            let set = &FMSPC_EOL;
            let fmspc_str: &str = &fmspc;
            if set.contains(fmspc_str) {
                warn!("The CPU is deprecated");
            }
            // fmspc.starts_with("0090")
        } else {
            warn!("failed to fetch fmspc from attestation");
        }

        true
    }

    fn decode_jwt(jwt_token: &str) -> Result<serde_json::Value, Box<dyn std::error::Error>> {
        let parts: Vec<&str> = jwt_token.split('.').collect();
        if parts.len() != 3 {
            return Err("JWT must have exactly 3 parts".into());
        }

        let (header_b64, claims_b64, sig_b64) = (parts[0], parts[1], parts[2]);

        let header_bytes = my_decode_base64(header_b64)?;
        let header_json: Value = serde_json::from_slice(&header_bytes)?;

        // Base64url decode and JSON parse claims
        let claims_bytes = my_decode_base64(claims_b64)?;
        let claims_json: Value = serde_json::from_slice(&claims_bytes)?;

        // Base64url decode signature (raw bytes)
        let signature_bytes = my_decode_base64(sig_b64)?;

        // println!("JWT header {}", &header_json);
        // println!("JWT claims {}", &claims_json);
        // println!("JWT signature {}", hex::encode(&signature_bytes));

        let kid_str = header_json
            .get("kid")
            .and_then(|v| v.as_str())
            .ok_or("missing 'kid' in header")?;

        //println!("kid_str {}", kid_str);

        let kid_bytes = base64::decode(kid_str)?;
        //println!("Kid {}", hex::encode(&kid_bytes));

        let known_keys = &KNOWN_JWT_KEYS;

        if let Some(verifying_key) = known_keys.coll.get(&kid_bytes) {
            // 3️⃣ Prepare the signed message (header + '.' + claims)
            let mut message = Vec::new();
            message.extend_from_slice(header_b64.as_bytes());
            message.push(b'.');
            message.extend_from_slice(claims_b64.as_bytes());

            let signature = rsa::pkcs1v15::Signature::try_from(signature_bytes.as_slice())
                .map_err(|e| format!("invalid signature: {e}"))?;

            // 5️⃣ Verify signature
            verifying_key
                .verify(&message, &signature)
                .map_err(|_| "invalid signature")?;

            println!("sig valid");
        } else {
            return Err(format!("Unknown kid: {}", kid_str).into());
        }

        Ok(claims_json)
    }

    pub fn verify_jwt_token(&self) -> bool {
        if self.jwt_token.is_empty() {
            return false;
        }

        let s = match std::str::from_utf8(&self.jwt_token) {
            Ok(s) => s,
            Err(e) => {
                println!("Not a valid decode_jwt token: {}", e);
                return false;
            }
        };

        let _token = match Self::decode_jwt(s) {
            Ok(x) => x,
            Err(e) => {
                println!("decode_jwt failed: {}", e);
                return false;
            }
        };

        false
    }
}

pub fn verify_quote_sgx(
    attestation: &AttestationCombined,
    time_s: i64,
    check_ppid_wl: bool,
) -> Result<(sgx_report_body_t, sgx_ql_qv_result_t), sgx_status_t> {
    let qv_result = verify_quote_any(&attestation.quote, &attestation.coll, time_s)?;

    if attestation.quote.len() < mem::size_of::<sgx_quote_t>() {
        trace!("Quote too small");
        return Err(sgx_status_t::SGX_ERROR_UNEXPECTED);
    }

    let my_p_quote = attestation.quote.as_ptr() as *const sgx_quote_t;

    unsafe {
        let version = (*my_p_quote).version;
        if version != 3 {
            trace!("Unrecognized quote version: {}", version);
            Err(sgx_status_t::SGX_ERROR_UNEXPECTED)
        } else {
            let report_body = (*my_p_quote).report_body;

            if !attestation.verify_fmspc() {
                return Err(sgx_status_t::SGX_ERROR_UNEXPECTED);
            }

            let is_in_wl = match attestation.extract_cpu_cert() {
                Some(ppid) => {
                    let ppid_addr = crate::registration::offchain::calculate_truncated_hash(&ppid);

                    let wl = &PPID_WHITELIST;
                    if wl.contains(&ppid_addr) {
                        true
                    } else {
                        println!("Unknown Machine ID: {}", orig_hex::encode(&ppid_addr));
                        false
                    }
                }
                None => {
                    println!("Machine ID couldn't be extracted");
                    false
                }
            };

            let jwt_token_valid = attestation.verify_jwt_token();

            if check_ppid_wl && (!is_in_wl && !jwt_token_valid) {
                return Err(sgx_status_t::SGX_ERROR_UNEXPECTED);
            }

            Ok((report_body, qv_result))
        }
    }
}

#[cfg(feature = "SGX_MODE_HW")]
fn test_sgx_call_res(
    res: sgx_status_t,
    retval: sgx_status_t,
) -> Result<sgx_status_t, sgx_status_t> {
    if sgx_status_t::SGX_SUCCESS != res {
        return Err(res);
    }

    if sgx_status_t::SGX_SUCCESS != retval {
        return Err(retval);
    }

    Ok(sgx_status_t::SGX_SUCCESS)
}

#[cfg(not(feature = "SGX_MODE_HW"))]
pub fn get_quote_ecdsa(_pub_k: &[u8]) -> Result<AttestationCombined, sgx_status_t> {
    Err(sgx_status_t::SGX_ERROR_NO_DEVICE)
}

#[cfg(feature = "SGX_MODE_HW")]
pub fn get_quote_ecdsa_untested(pub_k: &[u8]) -> Result<AttestationCombined, sgx_status_t> {
    let mut qe_target_info = sgx_target_info_t::default();
    let mut quote_size: u32 = 0;
    let mut rt: sgx_status_t = sgx_status_t::default();

    let mut res: sgx_status_t = unsafe {
        ocall_get_quote_ecdsa_params(
            &mut rt as *mut sgx_status_t,
            &mut qe_target_info,
            &mut quote_size,
        )
    };

    if let Err(e) = test_sgx_call_res(res, rt) {
        trace!("ocall_get_quote_ecdsa_params err = {}", e);
        return Err(e);
    }

    trace!("ECDSA quote size = {}", quote_size);

    let mut report_data: sgx_report_data_t = sgx_report_data_t::default();
    report_data.d[..pub_k.len()].copy_from_slice(pub_k);

    let my_report: sgx_report_t = match rsgx_create_report(&qe_target_info, &report_data) {
        Ok(r) => r,
        Err(e) => {
            trace!("sgx_create_report = {}", e);
            return Err(e);
        }
    };

    let mut vec_quote: Vec<u8> = vec![0; quote_size as usize];

    res = unsafe {
        ocall_get_quote_ecdsa(
            &mut rt as *mut sgx_status_t,
            &my_report,
            vec_quote.as_mut_ptr(),
            vec_quote.len() as u32,
        )
    };

    if let Err(e) = test_sgx_call_res(res, rt) {
        trace!("ocall_get_quote_ecdsa err = {}", e);
        return Err(e);
    }

    let mut vec_coll: Vec<u8> = vec![0; 0x4000];
    let mut size_coll: u32 = 0;

    res = unsafe {
        ocall_get_quote_ecdsa_collateral(
            &mut rt as *mut sgx_status_t,
            vec_quote.as_ptr(),
            vec_quote.len() as u32,
            vec_coll.as_mut_ptr(),
            vec_coll.len() as u32,
            &mut size_coll,
        )
    };

    if let Err(e) = test_sgx_call_res(res, rt) {
        trace!("ocall_get_quote_ecdsa_collateral err = {}", e);
        return Err(e);
    }

    trace!("Collateral size = {}", size_coll);

    let call_again = size_coll > vec_coll.len() as u32;
    vec_coll.resize(size_coll as usize, 0);

    if call_again {
        res = unsafe {
            ocall_get_quote_ecdsa_collateral(
                &mut rt as *mut sgx_status_t,
                vec_quote.as_ptr(),
                vec_quote.len() as u32,
                vec_coll.as_mut_ptr(),
                vec_coll.len() as u32,
                &mut size_coll,
            )
        };

        if let Err(e) = test_sgx_call_res(res, rt) {
            trace!("ocall_get_quote_ecdsa_collateral again err = {}", e);
            return Err(e);
        }
    }

    println!(
        "mr_signer = {}",
        orig_hex::encode(my_report.body.mr_signer.m)
    );
    println!(
        "mr_enclave = {}",
        orig_hex::encode(my_report.body.mr_enclave.m)
    );
    println!(
        "report_data = {}",
        orig_hex::encode(my_report.body.report_data.d)
    );

    Ok(AttestationCombined {
        quote: vec_quote,
        coll: vec_coll,
        jwt_token: Vec::new(),
    })
}

#[cfg(feature = "SGX_MODE_HW")]
pub fn get_quote_ecdsa(pub_k: &[u8]) -> Result<AttestationCombined, sgx_status_t> {
    let attestation = get_quote_ecdsa_untested(pub_k)?;

    // test self
    match verify_quote_sgx(&attestation, 0, false) {
        Ok(r) => {
            trace!("Self quote verified ok");
            if r.1 != sgx_ql_qv_result_t::SGX_QL_QV_RESULT_OK {
                // TODO: strict policy wrt own quote verification
                trace!("WARNING: {}", r.1);
            }
        }
        Err(e) => {
            trace!("Self quote verification failed: {}", e);
            return Err(e);
        }
    };

    Ok(attestation)
}
