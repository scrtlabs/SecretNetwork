// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: secret/tss/v1/types.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// KeySetStatus defines the status of a KeySet
type KeySetStatus int32

const (
	KeySetStatus_KEY_SET_STATUS_UNSPECIFIED KeySetStatus = 0
	KeySetStatus_KEY_SET_STATUS_PENDING_DKG KeySetStatus = 1
	KeySetStatus_KEY_SET_STATUS_ACTIVE      KeySetStatus = 2
	KeySetStatus_KEY_SET_STATUS_FAILED      KeySetStatus = 3
)

var KeySetStatus_name = map[int32]string{
	0: "KEY_SET_STATUS_UNSPECIFIED",
	1: "KEY_SET_STATUS_PENDING_DKG",
	2: "KEY_SET_STATUS_ACTIVE",
	3: "KEY_SET_STATUS_FAILED",
}

var KeySetStatus_value = map[string]int32{
	"KEY_SET_STATUS_UNSPECIFIED": 0,
	"KEY_SET_STATUS_PENDING_DKG": 1,
	"KEY_SET_STATUS_ACTIVE":      2,
	"KEY_SET_STATUS_FAILED":      3,
}

func (x KeySetStatus) String() string {
	return proto.EnumName(KeySetStatus_name, int32(x))
}

func (KeySetStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1eab323200622b2d, []int{0}
}

// DKGState defines the state of a DKG session
type DKGState int32

const (
	DKGState_DKG_STATE_UNSPECIFIED    DKGState = 0
	DKGState_DKG_STATE_ROUND1         DKGState = 1
	DKGState_DKG_STATE_ROUND2         DKGState = 2
	DKGState_DKG_STATE_KEY_SUBMISSION DKGState = 3
	DKGState_DKG_STATE_COMPLETE       DKGState = 4
	DKGState_DKG_STATE_FAILED         DKGState = 5
)

var DKGState_name = map[int32]string{
	0: "DKG_STATE_UNSPECIFIED",
	1: "DKG_STATE_ROUND1",
	2: "DKG_STATE_ROUND2",
	3: "DKG_STATE_KEY_SUBMISSION",
	4: "DKG_STATE_COMPLETE",
	5: "DKG_STATE_FAILED",
}

var DKGState_value = map[string]int32{
	"DKG_STATE_UNSPECIFIED":    0,
	"DKG_STATE_ROUND1":         1,
	"DKG_STATE_ROUND2":         2,
	"DKG_STATE_KEY_SUBMISSION": 3,
	"DKG_STATE_COMPLETE":       4,
	"DKG_STATE_FAILED":         5,
}

func (x DKGState) String() string {
	return proto.EnumName(DKGState_name, int32(x))
}

func (DKGState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1eab323200622b2d, []int{1}
}

// SigningState defines the state of a signing session
type SigningState int32

const (
	SigningState_SIGNING_STATE_UNSPECIFIED SigningState = 0
	SigningState_SIGNING_STATE_ROUND1      SigningState = 1
	SigningState_SIGNING_STATE_ROUND2      SigningState = 2
	SigningState_SIGNING_STATE_COMPLETE    SigningState = 3
	SigningState_SIGNING_STATE_FAILED      SigningState = 4
)

var SigningState_name = map[int32]string{
	0: "SIGNING_STATE_UNSPECIFIED",
	1: "SIGNING_STATE_ROUND1",
	2: "SIGNING_STATE_ROUND2",
	3: "SIGNING_STATE_COMPLETE",
	4: "SIGNING_STATE_FAILED",
}

var SigningState_value = map[string]int32{
	"SIGNING_STATE_UNSPECIFIED": 0,
	"SIGNING_STATE_ROUND1":      1,
	"SIGNING_STATE_ROUND2":      2,
	"SIGNING_STATE_COMPLETE":    3,
	"SIGNING_STATE_FAILED":      4,
}

func (x SigningState) String() string {
	return proto.EnumName(SigningState_name, int32(x))
}

func (SigningState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1eab323200622b2d, []int{2}
}

// SigningRequestStatus defines the status of a signing request
type SigningRequestStatus int32

const (
	SigningRequestStatus_SIGNING_REQUEST_STATUS_UNSPECIFIED SigningRequestStatus = 0
	SigningRequestStatus_SIGNING_REQUEST_STATUS_PENDING     SigningRequestStatus = 1
	SigningRequestStatus_SIGNING_REQUEST_STATUS_ROUND1      SigningRequestStatus = 2
	SigningRequestStatus_SIGNING_REQUEST_STATUS_ROUND2      SigningRequestStatus = 3
	SigningRequestStatus_SIGNING_REQUEST_STATUS_COMPLETE    SigningRequestStatus = 4
	SigningRequestStatus_SIGNING_REQUEST_STATUS_FAILED      SigningRequestStatus = 5
)

var SigningRequestStatus_name = map[int32]string{
	0: "SIGNING_REQUEST_STATUS_UNSPECIFIED",
	1: "SIGNING_REQUEST_STATUS_PENDING",
	2: "SIGNING_REQUEST_STATUS_ROUND1",
	3: "SIGNING_REQUEST_STATUS_ROUND2",
	4: "SIGNING_REQUEST_STATUS_COMPLETE",
	5: "SIGNING_REQUEST_STATUS_FAILED",
}

var SigningRequestStatus_value = map[string]int32{
	"SIGNING_REQUEST_STATUS_UNSPECIFIED": 0,
	"SIGNING_REQUEST_STATUS_PENDING":     1,
	"SIGNING_REQUEST_STATUS_ROUND1":      2,
	"SIGNING_REQUEST_STATUS_ROUND2":      3,
	"SIGNING_REQUEST_STATUS_COMPLETE":    4,
	"SIGNING_REQUEST_STATUS_FAILED":      5,
}

func (x SigningRequestStatus) String() string {
	return proto.EnumName(SigningRequestStatus_name, int32(x))
}

func (SigningRequestStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1eab323200622b2d, []int{3}
}

// Params defines the module parameters
type Params struct {
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_1eab323200622b2d, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

// KeySet represents a threshold signature key set
type KeySet struct {
	Id            string       `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Owner         string       `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
	Threshold     uint32       `protobuf:"varint,3,opt,name=threshold,proto3" json:"threshold,omitempty"`
	MaxSigners    uint32       `protobuf:"varint,4,opt,name=max_signers,json=maxSigners,proto3" json:"max_signers,omitempty"`
	Participants  []string     `protobuf:"bytes,5,rep,name=participants,proto3" json:"participants,omitempty"`
	GroupPubkey   []byte       `protobuf:"bytes,6,opt,name=group_pubkey,json=groupPubkey,proto3" json:"group_pubkey,omitempty"`
	Status        KeySetStatus `protobuf:"varint,7,opt,name=status,proto3,enum=secret.tss.v1.KeySetStatus" json:"status,omitempty"`
	Description   string       `protobuf:"bytes,8,opt,name=description,proto3" json:"description,omitempty"`
	CreatedHeight int64        `protobuf:"varint,9,opt,name=created_height,json=createdHeight,proto3" json:"created_height,omitempty"`
}

func (m *KeySet) Reset()         { *m = KeySet{} }
func (m *KeySet) String() string { return proto.CompactTextString(m) }
func (*KeySet) ProtoMessage()    {}
func (*KeySet) Descriptor() ([]byte, []int) {
	return fileDescriptor_1eab323200622b2d, []int{1}
}
func (m *KeySet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeySet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeySet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeySet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeySet.Merge(m, src)
}
func (m *KeySet) XXX_Size() int {
	return m.Size()
}
func (m *KeySet) XXX_DiscardUnknown() {
	xxx_messageInfo_KeySet.DiscardUnknown(m)
}

var xxx_messageInfo_KeySet proto.InternalMessageInfo

func (m *KeySet) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *KeySet) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *KeySet) GetThreshold() uint32 {
	if m != nil {
		return m.Threshold
	}
	return 0
}

func (m *KeySet) GetMaxSigners() uint32 {
	if m != nil {
		return m.MaxSigners
	}
	return 0
}

func (m *KeySet) GetParticipants() []string {
	if m != nil {
		return m.Participants
	}
	return nil
}

func (m *KeySet) GetGroupPubkey() []byte {
	if m != nil {
		return m.GroupPubkey
	}
	return nil
}

func (m *KeySet) GetStatus() KeySetStatus {
	if m != nil {
		return m.Status
	}
	return KeySetStatus_KEY_SET_STATUS_UNSPECIFIED
}

func (m *KeySet) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *KeySet) GetCreatedHeight() int64 {
	if m != nil {
		return m.CreatedHeight
	}
	return 0
}

// KeyShare represents a validator's share of a threshold key
// The secret share is encrypted with the validator's public key (Ed25519â†’X25519)
type KeyShare struct {
	KeySetId         string `protobuf:"bytes,1,opt,name=key_set_id,json=keySetId,proto3" json:"key_set_id,omitempty"`
	ValidatorAddress string `protobuf:"bytes,2,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address,omitempty"`
	ShareData        []byte `protobuf:"bytes,3,opt,name=share_data,json=shareData,proto3" json:"share_data,omitempty"`
	GroupPubkey      []byte `protobuf:"bytes,4,opt,name=group_pubkey,json=groupPubkey,proto3" json:"group_pubkey,omitempty"`
	CreatedHeight    int64  `protobuf:"varint,5,opt,name=created_height,json=createdHeight,proto3" json:"created_height,omitempty"`
	// Encrypted FROST secret share (NaCl box sealed with validator's X25519 pubkey)
	EncryptedSecretShare []byte `protobuf:"bytes,6,opt,name=encrypted_secret_share,json=encryptedSecretShare,proto3" json:"encrypted_secret_share,omitempty"`
	// Encrypted FROST public shares (NaCl box sealed with validator's X25519 pubkey)
	EncryptedPublicShares []byte `protobuf:"bytes,7,opt,name=encrypted_public_shares,json=encryptedPublicShares,proto3" json:"encrypted_public_shares,omitempty"`
	// Ephemeral public key used for encryption (needed for decryption)
	EphemeralPubkey []byte `protobuf:"bytes,8,opt,name=ephemeral_pubkey,json=ephemeralPubkey,proto3" json:"ephemeral_pubkey,omitempty"`
}

func (m *KeyShare) Reset()         { *m = KeyShare{} }
func (m *KeyShare) String() string { return proto.CompactTextString(m) }
func (*KeyShare) ProtoMessage()    {}
func (*KeyShare) Descriptor() ([]byte, []int) {
	return fileDescriptor_1eab323200622b2d, []int{2}
}
func (m *KeyShare) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyShare) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyShare.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyShare) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyShare.Merge(m, src)
}
func (m *KeyShare) XXX_Size() int {
	return m.Size()
}
func (m *KeyShare) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyShare.DiscardUnknown(m)
}

var xxx_messageInfo_KeyShare proto.InternalMessageInfo

func (m *KeyShare) GetKeySetId() string {
	if m != nil {
		return m.KeySetId
	}
	return ""
}

func (m *KeyShare) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *KeyShare) GetShareData() []byte {
	if m != nil {
		return m.ShareData
	}
	return nil
}

func (m *KeyShare) GetGroupPubkey() []byte {
	if m != nil {
		return m.GroupPubkey
	}
	return nil
}

func (m *KeyShare) GetCreatedHeight() int64 {
	if m != nil {
		return m.CreatedHeight
	}
	return 0
}

func (m *KeyShare) GetEncryptedSecretShare() []byte {
	if m != nil {
		return m.EncryptedSecretShare
	}
	return nil
}

func (m *KeyShare) GetEncryptedPublicShares() []byte {
	if m != nil {
		return m.EncryptedPublicShares
	}
	return nil
}

func (m *KeyShare) GetEphemeralPubkey() []byte {
	if m != nil {
		return m.EphemeralPubkey
	}
	return nil
}

// DKG Session and Round data
type DKGSession struct {
	Id            string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	KeySetId      string   `protobuf:"bytes,2,opt,name=key_set_id,json=keySetId,proto3" json:"key_set_id,omitempty"`
	State         DKGState `protobuf:"varint,3,opt,name=state,proto3,enum=secret.tss.v1.DKGState" json:"state,omitempty"`
	Threshold     uint32   `protobuf:"varint,4,opt,name=threshold,proto3" json:"threshold,omitempty"`
	MaxSigners    uint32   `protobuf:"varint,5,opt,name=max_signers,json=maxSigners,proto3" json:"max_signers,omitempty"`
	Participants  []string `protobuf:"bytes,6,rep,name=participants,proto3" json:"participants,omitempty"`
	StartHeight   int64    `protobuf:"varint,7,opt,name=start_height,json=startHeight,proto3" json:"start_height,omitempty"`
	TimeoutHeight int64    `protobuf:"varint,8,opt,name=timeout_height,json=timeoutHeight,proto3" json:"timeout_height,omitempty"`
}

func (m *DKGSession) Reset()         { *m = DKGSession{} }
func (m *DKGSession) String() string { return proto.CompactTextString(m) }
func (*DKGSession) ProtoMessage()    {}
func (*DKGSession) Descriptor() ([]byte, []int) {
	return fileDescriptor_1eab323200622b2d, []int{3}
}
func (m *DKGSession) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DKGSession) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DKGSession.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DKGSession) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DKGSession.Merge(m, src)
}
func (m *DKGSession) XXX_Size() int {
	return m.Size()
}
func (m *DKGSession) XXX_DiscardUnknown() {
	xxx_messageInfo_DKGSession.DiscardUnknown(m)
}

var xxx_messageInfo_DKGSession proto.InternalMessageInfo

func (m *DKGSession) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DKGSession) GetKeySetId() string {
	if m != nil {
		return m.KeySetId
	}
	return ""
}

func (m *DKGSession) GetState() DKGState {
	if m != nil {
		return m.State
	}
	return DKGState_DKG_STATE_UNSPECIFIED
}

func (m *DKGSession) GetThreshold() uint32 {
	if m != nil {
		return m.Threshold
	}
	return 0
}

func (m *DKGSession) GetMaxSigners() uint32 {
	if m != nil {
		return m.MaxSigners
	}
	return 0
}

func (m *DKGSession) GetParticipants() []string {
	if m != nil {
		return m.Participants
	}
	return nil
}

func (m *DKGSession) GetStartHeight() int64 {
	if m != nil {
		return m.StartHeight
	}
	return 0
}

func (m *DKGSession) GetTimeoutHeight() int64 {
	if m != nil {
		return m.TimeoutHeight
	}
	return 0
}

type DKGRound1Data struct {
	ValidatorAddress string `protobuf:"bytes,1,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address,omitempty"`
	Commitment       []byte `protobuf:"bytes,2,opt,name=commitment,proto3" json:"commitment,omitempty"`
	SubmittedHeight  int64  `protobuf:"varint,3,opt,name=submitted_height,json=submittedHeight,proto3" json:"submitted_height,omitempty"`
}

func (m *DKGRound1Data) Reset()         { *m = DKGRound1Data{} }
func (m *DKGRound1Data) String() string { return proto.CompactTextString(m) }
func (*DKGRound1Data) ProtoMessage()    {}
func (*DKGRound1Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_1eab323200622b2d, []int{4}
}
func (m *DKGRound1Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DKGRound1Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DKGRound1Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DKGRound1Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DKGRound1Data.Merge(m, src)
}
func (m *DKGRound1Data) XXX_Size() int {
	return m.Size()
}
func (m *DKGRound1Data) XXX_DiscardUnknown() {
	xxx_messageInfo_DKGRound1Data.DiscardUnknown(m)
}

var xxx_messageInfo_DKGRound1Data proto.InternalMessageInfo

func (m *DKGRound1Data) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *DKGRound1Data) GetCommitment() []byte {
	if m != nil {
		return m.Commitment
	}
	return nil
}

func (m *DKGRound1Data) GetSubmittedHeight() int64 {
	if m != nil {
		return m.SubmittedHeight
	}
	return 0
}

type DKGRound2Data struct {
	ValidatorAddress string `protobuf:"bytes,1,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address,omitempty"`
	Share            []byte `protobuf:"bytes,2,opt,name=share,proto3" json:"share,omitempty"`
	SubmittedHeight  int64  `protobuf:"varint,3,opt,name=submitted_height,json=submittedHeight,proto3" json:"submitted_height,omitempty"`
}

func (m *DKGRound2Data) Reset()         { *m = DKGRound2Data{} }
func (m *DKGRound2Data) String() string { return proto.CompactTextString(m) }
func (*DKGRound2Data) ProtoMessage()    {}
func (*DKGRound2Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_1eab323200622b2d, []int{5}
}
func (m *DKGRound2Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DKGRound2Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DKGRound2Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DKGRound2Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DKGRound2Data.Merge(m, src)
}
func (m *DKGRound2Data) XXX_Size() int {
	return m.Size()
}
func (m *DKGRound2Data) XXX_DiscardUnknown() {
	xxx_messageInfo_DKGRound2Data.DiscardUnknown(m)
}

var xxx_messageInfo_DKGRound2Data proto.InternalMessageInfo

func (m *DKGRound2Data) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *DKGRound2Data) GetShare() []byte {
	if m != nil {
		return m.Share
	}
	return nil
}

func (m *DKGRound2Data) GetSubmittedHeight() int64 {
	if m != nil {
		return m.SubmittedHeight
	}
	return 0
}

// DKGKeySubmission contains a validator's encrypted secret share for on-chain storage
type DKGKeySubmission struct {
	ValidatorAddress string `protobuf:"bytes,1,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address,omitempty"`
	// Encrypted FROST secret share (NaCl box sealed with validator's X25519 pubkey)
	EncryptedSecretShare []byte `protobuf:"bytes,2,opt,name=encrypted_secret_share,json=encryptedSecretShare,proto3" json:"encrypted_secret_share,omitempty"`
	// Encrypted FROST public shares (NaCl box sealed with validator's X25519 pubkey)
	EncryptedPublicShares []byte `protobuf:"bytes,3,opt,name=encrypted_public_shares,json=encryptedPublicShares,proto3" json:"encrypted_public_shares,omitempty"`
	// Ephemeral public key used for encryption (needed for decryption)
	EphemeralPubkey []byte `protobuf:"bytes,4,opt,name=ephemeral_pubkey,json=ephemeralPubkey,proto3" json:"ephemeral_pubkey,omitempty"`
	SubmittedHeight int64  `protobuf:"varint,5,opt,name=submitted_height,json=submittedHeight,proto3" json:"submitted_height,omitempty"`
}

func (m *DKGKeySubmission) Reset()         { *m = DKGKeySubmission{} }
func (m *DKGKeySubmission) String() string { return proto.CompactTextString(m) }
func (*DKGKeySubmission) ProtoMessage()    {}
func (*DKGKeySubmission) Descriptor() ([]byte, []int) {
	return fileDescriptor_1eab323200622b2d, []int{6}
}
func (m *DKGKeySubmission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DKGKeySubmission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DKGKeySubmission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DKGKeySubmission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DKGKeySubmission.Merge(m, src)
}
func (m *DKGKeySubmission) XXX_Size() int {
	return m.Size()
}
func (m *DKGKeySubmission) XXX_DiscardUnknown() {
	xxx_messageInfo_DKGKeySubmission.DiscardUnknown(m)
}

var xxx_messageInfo_DKGKeySubmission proto.InternalMessageInfo

func (m *DKGKeySubmission) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *DKGKeySubmission) GetEncryptedSecretShare() []byte {
	if m != nil {
		return m.EncryptedSecretShare
	}
	return nil
}

func (m *DKGKeySubmission) GetEncryptedPublicShares() []byte {
	if m != nil {
		return m.EncryptedPublicShares
	}
	return nil
}

func (m *DKGKeySubmission) GetEphemeralPubkey() []byte {
	if m != nil {
		return m.EphemeralPubkey
	}
	return nil
}

func (m *DKGKeySubmission) GetSubmittedHeight() int64 {
	if m != nil {
		return m.SubmittedHeight
	}
	return 0
}

// Signing Request and Session data
type SigningRequest struct {
	Id            string               `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	KeySetId      string               `protobuf:"bytes,2,opt,name=key_set_id,json=keySetId,proto3" json:"key_set_id,omitempty"`
	Requester     string               `protobuf:"bytes,3,opt,name=requester,proto3" json:"requester,omitempty"`
	MessageHash   []byte               `protobuf:"bytes,4,opt,name=message_hash,json=messageHash,proto3" json:"message_hash,omitempty"`
	Callback      string               `protobuf:"bytes,5,opt,name=callback,proto3" json:"callback,omitempty"`
	Status        SigningRequestStatus `protobuf:"varint,6,opt,name=status,proto3,enum=secret.tss.v1.SigningRequestStatus" json:"status,omitempty"`
	Signature     []byte               `protobuf:"bytes,7,opt,name=signature,proto3" json:"signature,omitempty"`
	CreatedHeight int64                `protobuf:"varint,8,opt,name=created_height,json=createdHeight,proto3" json:"created_height,omitempty"`
}

func (m *SigningRequest) Reset()         { *m = SigningRequest{} }
func (m *SigningRequest) String() string { return proto.CompactTextString(m) }
func (*SigningRequest) ProtoMessage()    {}
func (*SigningRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1eab323200622b2d, []int{7}
}
func (m *SigningRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SigningRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SigningRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SigningRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SigningRequest.Merge(m, src)
}
func (m *SigningRequest) XXX_Size() int {
	return m.Size()
}
func (m *SigningRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SigningRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SigningRequest proto.InternalMessageInfo

func (m *SigningRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *SigningRequest) GetKeySetId() string {
	if m != nil {
		return m.KeySetId
	}
	return ""
}

func (m *SigningRequest) GetRequester() string {
	if m != nil {
		return m.Requester
	}
	return ""
}

func (m *SigningRequest) GetMessageHash() []byte {
	if m != nil {
		return m.MessageHash
	}
	return nil
}

func (m *SigningRequest) GetCallback() string {
	if m != nil {
		return m.Callback
	}
	return ""
}

func (m *SigningRequest) GetStatus() SigningRequestStatus {
	if m != nil {
		return m.Status
	}
	return SigningRequestStatus_SIGNING_REQUEST_STATUS_UNSPECIFIED
}

func (m *SigningRequest) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *SigningRequest) GetCreatedHeight() int64 {
	if m != nil {
		return m.CreatedHeight
	}
	return 0
}

type SigningSession struct {
	RequestId     string       `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	KeySetId      string       `protobuf:"bytes,2,opt,name=key_set_id,json=keySetId,proto3" json:"key_set_id,omitempty"`
	Threshold     uint32       `protobuf:"varint,3,opt,name=threshold,proto3" json:"threshold,omitempty"`
	Participants  []string     `protobuf:"bytes,4,rep,name=participants,proto3" json:"participants,omitempty"`
	State         SigningState `protobuf:"varint,5,opt,name=state,proto3,enum=secret.tss.v1.SigningState" json:"state,omitempty"`
	StartHeight   int64        `protobuf:"varint,6,opt,name=start_height,json=startHeight,proto3" json:"start_height,omitempty"`
	TimeoutHeight int64        `protobuf:"varint,7,opt,name=timeout_height,json=timeoutHeight,proto3" json:"timeout_height,omitempty"`
}

func (m *SigningSession) Reset()         { *m = SigningSession{} }
func (m *SigningSession) String() string { return proto.CompactTextString(m) }
func (*SigningSession) ProtoMessage()    {}
func (*SigningSession) Descriptor() ([]byte, []int) {
	return fileDescriptor_1eab323200622b2d, []int{8}
}
func (m *SigningSession) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SigningSession) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SigningSession.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SigningSession) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SigningSession.Merge(m, src)
}
func (m *SigningSession) XXX_Size() int {
	return m.Size()
}
func (m *SigningSession) XXX_DiscardUnknown() {
	xxx_messageInfo_SigningSession.DiscardUnknown(m)
}

var xxx_messageInfo_SigningSession proto.InternalMessageInfo

func (m *SigningSession) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *SigningSession) GetKeySetId() string {
	if m != nil {
		return m.KeySetId
	}
	return ""
}

func (m *SigningSession) GetThreshold() uint32 {
	if m != nil {
		return m.Threshold
	}
	return 0
}

func (m *SigningSession) GetParticipants() []string {
	if m != nil {
		return m.Participants
	}
	return nil
}

func (m *SigningSession) GetState() SigningState {
	if m != nil {
		return m.State
	}
	return SigningState_SIGNING_STATE_UNSPECIFIED
}

func (m *SigningSession) GetStartHeight() int64 {
	if m != nil {
		return m.StartHeight
	}
	return 0
}

func (m *SigningSession) GetTimeoutHeight() int64 {
	if m != nil {
		return m.TimeoutHeight
	}
	return 0
}

type SigningCommitment struct {
	ValidatorAddress string `protobuf:"bytes,1,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address,omitempty"`
	Commitment       []byte `protobuf:"bytes,2,opt,name=commitment,proto3" json:"commitment,omitempty"`
	SubmittedHeight  int64  `protobuf:"varint,3,opt,name=submitted_height,json=submittedHeight,proto3" json:"submitted_height,omitempty"`
}

func (m *SigningCommitment) Reset()         { *m = SigningCommitment{} }
func (m *SigningCommitment) String() string { return proto.CompactTextString(m) }
func (*SigningCommitment) ProtoMessage()    {}
func (*SigningCommitment) Descriptor() ([]byte, []int) {
	return fileDescriptor_1eab323200622b2d, []int{9}
}
func (m *SigningCommitment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SigningCommitment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SigningCommitment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SigningCommitment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SigningCommitment.Merge(m, src)
}
func (m *SigningCommitment) XXX_Size() int {
	return m.Size()
}
func (m *SigningCommitment) XXX_DiscardUnknown() {
	xxx_messageInfo_SigningCommitment.DiscardUnknown(m)
}

var xxx_messageInfo_SigningCommitment proto.InternalMessageInfo

func (m *SigningCommitment) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *SigningCommitment) GetCommitment() []byte {
	if m != nil {
		return m.Commitment
	}
	return nil
}

func (m *SigningCommitment) GetSubmittedHeight() int64 {
	if m != nil {
		return m.SubmittedHeight
	}
	return 0
}

type SignatureShare struct {
	ValidatorAddress string `protobuf:"bytes,1,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address,omitempty"`
	Share            []byte `protobuf:"bytes,2,opt,name=share,proto3" json:"share,omitempty"`
	SubmittedHeight  int64  `protobuf:"varint,3,opt,name=submitted_height,json=submittedHeight,proto3" json:"submitted_height,omitempty"`
}

func (m *SignatureShare) Reset()         { *m = SignatureShare{} }
func (m *SignatureShare) String() string { return proto.CompactTextString(m) }
func (*SignatureShare) ProtoMessage()    {}
func (*SignatureShare) Descriptor() ([]byte, []int) {
	return fileDescriptor_1eab323200622b2d, []int{10}
}
func (m *SignatureShare) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignatureShare) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignatureShare.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignatureShare) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignatureShare.Merge(m, src)
}
func (m *SignatureShare) XXX_Size() int {
	return m.Size()
}
func (m *SignatureShare) XXX_DiscardUnknown() {
	xxx_messageInfo_SignatureShare.DiscardUnknown(m)
}

var xxx_messageInfo_SignatureShare proto.InternalMessageInfo

func (m *SignatureShare) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *SignatureShare) GetShare() []byte {
	if m != nil {
		return m.Share
	}
	return nil
}

func (m *SignatureShare) GetSubmittedHeight() int64 {
	if m != nil {
		return m.SubmittedHeight
	}
	return 0
}

func init() {
	proto.RegisterEnum("secret.tss.v1.KeySetStatus", KeySetStatus_name, KeySetStatus_value)
	proto.RegisterEnum("secret.tss.v1.DKGState", DKGState_name, DKGState_value)
	proto.RegisterEnum("secret.tss.v1.SigningState", SigningState_name, SigningState_value)
	proto.RegisterEnum("secret.tss.v1.SigningRequestStatus", SigningRequestStatus_name, SigningRequestStatus_value)
	proto.RegisterType((*Params)(nil), "secret.tss.v1.Params")
	proto.RegisterType((*KeySet)(nil), "secret.tss.v1.KeySet")
	proto.RegisterType((*KeyShare)(nil), "secret.tss.v1.KeyShare")
	proto.RegisterType((*DKGSession)(nil), "secret.tss.v1.DKGSession")
	proto.RegisterType((*DKGRound1Data)(nil), "secret.tss.v1.DKGRound1Data")
	proto.RegisterType((*DKGRound2Data)(nil), "secret.tss.v1.DKGRound2Data")
	proto.RegisterType((*DKGKeySubmission)(nil), "secret.tss.v1.DKGKeySubmission")
	proto.RegisterType((*SigningRequest)(nil), "secret.tss.v1.SigningRequest")
	proto.RegisterType((*SigningSession)(nil), "secret.tss.v1.SigningSession")
	proto.RegisterType((*SigningCommitment)(nil), "secret.tss.v1.SigningCommitment")
	proto.RegisterType((*SignatureShare)(nil), "secret.tss.v1.SignatureShare")
}

func init() { proto.RegisterFile("secret/tss/v1/types.proto", fileDescriptor_1eab323200622b2d) }

var fileDescriptor_1eab323200622b2d = []byte{
	// 1129 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x57, 0x4d, 0x73, 0xdb, 0x44,
	0x18, 0x8e, 0xe4, 0x8f, 0xda, 0x6f, 0x1c, 0x57, 0xdd, 0x71, 0x5b, 0x25, 0x24, 0x8e, 0xeb, 0x4e,
	0x19, 0x13, 0xa6, 0xf6, 0x24, 0x65, 0x38, 0xc0, 0x29, 0x8d, 0x55, 0xd7, 0xe3, 0xd6, 0x31, 0x52,
	0xc2, 0x0c, 0x5c, 0x34, 0x6b, 0x69, 0xc7, 0xd6, 0xc4, 0xb2, 0x8c, 0x76, 0x9d, 0x26, 0x07, 0xb8,
	0xc0, 0x0c, 0x07, 0x38, 0x70, 0x82, 0x53, 0x67, 0xf8, 0x0d, 0xfc, 0x0a, 0x8e, 0xbd, 0xc1, 0x91,
	0x49, 0x2e, 0x1c, 0xf9, 0x09, 0x8c, 0x76, 0x65, 0xf9, 0x23, 0x32, 0x69, 0x38, 0xc0, 0xcd, 0x7a,
	0x9e, 0x77, 0xb5, 0xef, 0xc7, 0xb3, 0xcf, 0x5a, 0xb0, 0x4e, 0x89, 0xe5, 0x13, 0x56, 0x63, 0x94,
	0xd6, 0x4e, 0x77, 0x6b, 0xec, 0x7c, 0x44, 0x68, 0x75, 0xe4, 0x7b, 0xcc, 0x43, 0x6b, 0x82, 0xaa,
	0x32, 0x4a, 0xab, 0xa7, 0xbb, 0x1b, 0x85, 0x9e, 0xd7, 0xf3, 0x38, 0x53, 0x0b, 0x7e, 0x89, 0xa0,
	0x72, 0x1e, 0xd2, 0x1d, 0xec, 0x63, 0x97, 0x7e, 0x94, 0xfc, 0xf3, 0xe7, 0x6d, 0xa9, 0xfc, 0x8b,
	0x0c, 0xe9, 0x16, 0x39, 0x37, 0x08, 0x43, 0x79, 0x90, 0x1d, 0x5b, 0x95, 0x4a, 0x52, 0x25, 0xab,
	0xcb, 0x8e, 0x8d, 0x0a, 0x90, 0xf2, 0x5e, 0x0d, 0x89, 0xaf, 0xca, 0x1c, 0x12, 0x0f, 0x68, 0x13,
	0xb2, 0xac, 0xef, 0x13, 0xda, 0xf7, 0x06, 0xb6, 0x9a, 0x28, 0x49, 0x95, 0x35, 0x7d, 0x0a, 0xa0,
	0x6d, 0x58, 0x75, 0xf1, 0x99, 0x49, 0x9d, 0xde, 0x90, 0xf8, 0x54, 0x4d, 0x72, 0x1e, 0x5c, 0x7c,
	0x66, 0x08, 0x04, 0x95, 0x21, 0x37, 0xc2, 0x3e, 0x73, 0x2c, 0x67, 0x84, 0x87, 0x8c, 0xaa, 0xa9,
	0x52, 0xa2, 0x92, 0xd5, 0xe7, 0x30, 0xf4, 0x00, 0x72, 0x3d, 0xdf, 0x1b, 0x8f, 0xcc, 0xd1, 0xb8,
	0x7b, 0x42, 0xce, 0xd5, 0x74, 0x49, 0xaa, 0xe4, 0xf4, 0x55, 0x8e, 0x75, 0x38, 0x84, 0x9e, 0x40,
	0x9a, 0x32, 0xcc, 0xc6, 0x54, 0xbd, 0x55, 0x92, 0x2a, 0xf9, 0xbd, 0x77, 0xaa, 0x73, 0xc5, 0x57,
	0x45, 0x49, 0x06, 0x0f, 0xd1, 0xc3, 0x50, 0x54, 0x82, 0x55, 0x9b, 0x50, 0xcb, 0x77, 0x46, 0xcc,
	0xf1, 0x86, 0x6a, 0x86, 0x97, 0x35, 0x0b, 0xa1, 0x47, 0x90, 0xb7, 0x7c, 0x82, 0x19, 0xb1, 0xcd,
	0x3e, 0x71, 0x7a, 0x7d, 0xa6, 0x66, 0x4b, 0x52, 0x25, 0xa1, 0xaf, 0x85, 0xe8, 0x73, 0x0e, 0x96,
	0x7f, 0x93, 0x21, 0x13, 0xec, 0xd0, 0xc7, 0x3e, 0x41, 0x9b, 0x00, 0x27, 0xe4, 0xdc, 0xa4, 0x84,
	0x99, 0x51, 0xfb, 0x32, 0x27, 0x7c, 0xff, 0xa6, 0x8d, 0xde, 0x87, 0x3b, 0xa7, 0x78, 0xe0, 0xd8,
	0x98, 0x79, 0xbe, 0x89, 0x6d, 0xdb, 0x27, 0x94, 0x86, 0x0d, 0x55, 0x22, 0x62, 0x5f, 0xe0, 0x68,
	0x0b, 0x80, 0x06, 0xef, 0x34, 0x6d, 0xcc, 0x30, 0x6f, 0x6e, 0x4e, 0xcf, 0x72, 0xa4, 0x8e, 0x19,
	0xbe, 0xd2, 0x97, 0xe4, 0xd5, 0xbe, 0x5c, 0x2d, 0x20, 0x15, 0x53, 0x00, 0xfa, 0x00, 0xee, 0x91,
	0xa1, 0xe5, 0x9f, 0x8f, 0x82, 0x40, 0xd1, 0x39, 0x93, 0xef, 0x13, 0xf6, 0xba, 0x10, 0xb1, 0x06,
	0x27, 0x45, 0xa5, 0x1f, 0xc2, 0xfd, 0xe9, 0xaa, 0xd1, 0xb8, 0x3b, 0x70, 0x2c, 0xb1, 0x4a, 0x4c,
	0x21, 0xa7, 0xdf, 0x8d, 0xe8, 0x0e, 0x67, 0xf9, 0x32, 0x8a, 0xde, 0x03, 0x85, 0x8c, 0xfa, 0xc4,
	0x25, 0x3e, 0x1e, 0x4c, 0x72, 0xcf, 0xf0, 0x05, 0xb7, 0x23, 0x5c, 0xe4, 0x5f, 0xfe, 0x51, 0x06,
	0xa8, 0xb7, 0x1a, 0x06, 0xa1, 0x34, 0x98, 0xc7, 0xa2, 0x24, 0xe7, 0x7b, 0x2d, 0x2f, 0xf4, 0xfa,
	0x31, 0xa4, 0x82, 0x49, 0x13, 0xde, 0xb9, 0xfc, 0xde, 0xfd, 0x05, 0x4d, 0x04, 0xef, 0x0d, 0x68,
	0x5d, 0x44, 0xcd, 0x2b, 0x39, 0x79, 0x8d, 0x92, 0x53, 0xd7, 0x2a, 0x39, 0x1d, 0xaf, 0x64, 0xca,
	0xb0, 0xcf, 0x26, 0xc3, 0xb8, 0xc5, 0x87, 0xb1, 0xca, 0xb1, 0x70, 0x14, 0x8f, 0x20, 0xcf, 0x1c,
	0x97, 0x78, 0xe3, 0x28, 0x28, 0x23, 0x26, 0x16, 0xa2, 0xa1, 0xe4, 0xbe, 0x95, 0x60, 0xad, 0xde,
	0x6a, 0xe8, 0xde, 0x78, 0x68, 0xef, 0x72, 0x35, 0xc4, 0x2a, 0x4b, 0x5a, 0xa2, 0xac, 0x22, 0x80,
	0xe5, 0xb9, 0xae, 0xc3, 0x5c, 0x32, 0x64, 0xbc, 0x71, 0x39, 0x7d, 0x06, 0x09, 0x46, 0x44, 0xc7,
	0x5d, 0xd7, 0x61, 0x33, 0xca, 0x49, 0xf0, 0x3c, 0x6e, 0x47, 0x78, 0x98, 0xc9, 0x97, 0xd3, 0x44,
	0xf6, 0x6e, 0x9e, 0x48, 0x01, 0x52, 0x42, 0x68, 0x22, 0x07, 0xf1, 0x70, 0x93, 0xed, 0xbf, 0x96,
	0x41, 0xa9, 0xb7, 0x1a, 0xc1, 0xf1, 0x0b, 0x18, 0xa1, 0x93, 0x1b, 0xa5, 0xb0, 0x5c, 0xfc, 0xf2,
	0xbf, 0x13, 0x7f, 0xe2, 0xa6, 0xe2, 0x4f, 0xc6, 0x8a, 0x3f, 0xb6, 0x0b, 0xa9, 0xf8, 0x2e, 0xbc,
	0x96, 0x21, 0x1f, 0x08, 0xd1, 0x19, 0xf6, 0x74, 0xf2, 0xc5, 0x98, 0x50, 0x76, 0xc3, 0xb3, 0xb2,
	0x09, 0x59, 0x5f, 0x2c, 0x24, 0x3e, 0x2f, 0x20, 0xab, 0x4f, 0x81, 0x40, 0xb7, 0x2e, 0xa1, 0x14,
	0xf7, 0x88, 0xd9, 0xc7, 0xb4, 0x3f, 0x71, 0x9a, 0x10, 0x7b, 0x8e, 0x69, 0x1f, 0x6d, 0x40, 0xc6,
	0xc2, 0x83, 0x41, 0x17, 0x5b, 0x27, 0x3c, 0xc9, 0xac, 0x1e, 0x3d, 0xa3, 0x8f, 0x23, 0x77, 0x4e,
	0xf3, 0x93, 0xf8, 0x70, 0xe1, 0x24, 0xce, 0x67, 0xbe, 0xe0, 0xd2, 0x9b, 0x90, 0x0d, 0x0e, 0x1d,
	0x66, 0x63, 0x9f, 0x84, 0xbe, 0x32, 0x05, 0x62, 0x0c, 0x2e, 0x13, 0xe7, 0xd0, 0xdf, 0x4f, 0xfb,
	0x33, 0xf1, 0x92, 0x2d, 0x80, 0xb0, 0xc0, 0xa9, 0x4f, 0x4f, 0x4a, 0x6e, 0xbe, 0x45, 0xbb, 0xfe,
	0xe1, 0xd6, 0x5b, 0xb4, 0x82, 0x64, 0x8c, 0x15, 0xec, 0x4e, 0xcc, 0x29, 0x15, 0x7b, 0x61, 0x4d,
	0x92, 0x9d, 0x35, 0xa8, 0x45, 0xf7, 0x48, 0xbf, 0x8d, 0x7b, 0xdc, 0x8a, 0x73, 0x8f, 0xef, 0x24,
	0xb8, 0x13, 0xee, 0x70, 0x30, 0x3d, 0xf4, 0xff, 0x97, 0x83, 0x7c, 0x25, 0x66, 0xc3, 0x07, 0x2a,
	0x0e, 0xd7, 0x7f, 0x6a, 0x21, 0x3b, 0xdf, 0x48, 0x90, 0x9b, 0xfd, 0x83, 0x80, 0x8a, 0xb0, 0xd1,
	0xd2, 0x3e, 0x33, 0x0d, 0xed, 0xc8, 0x34, 0x8e, 0xf6, 0x8f, 0x8e, 0x0d, 0xf3, 0xb8, 0x6d, 0x74,
	0xb4, 0x83, 0xe6, 0xb3, 0xa6, 0x56, 0x57, 0x56, 0x62, 0xf8, 0x8e, 0xd6, 0xae, 0x37, 0xdb, 0x0d,
	0xb3, 0xde, 0x6a, 0x28, 0x12, 0x5a, 0x87, 0xbb, 0x0b, 0xfc, 0xfe, 0xc1, 0x51, 0xf3, 0x53, 0x4d,
	0x91, 0x63, 0xa8, 0x67, 0xfb, 0xcd, 0x17, 0x5a, 0x5d, 0x49, 0xec, 0xbc, 0x96, 0x20, 0x33, 0xb9,
	0x93, 0x82, 0xb8, 0x7a, 0xab, 0xc1, 0x63, 0xb4, 0x85, 0xdd, 0x0b, 0xdc, 0xf0, 0x42, 0x4a, 0x3f,
	0x3c, 0x6e, 0xd7, 0x77, 0x15, 0x29, 0x06, 0xdd, 0x53, 0x64, 0xb4, 0x09, 0xea, 0x14, 0xe5, 0x1b,
	0x1f, 0x3f, 0x7d, 0xd9, 0x34, 0x8c, 0xe6, 0x61, 0x5b, 0x49, 0xa0, 0x7b, 0x80, 0xa6, 0xec, 0xc1,
	0xe1, 0xcb, 0xce, 0x0b, 0xed, 0x48, 0x53, 0x92, 0xf3, 0xef, 0x0a, 0xf3, 0x4b, 0xed, 0xfc, 0x24,
	0x41, 0x6e, 0x56, 0x96, 0x68, 0x0b, 0xd6, 0x8d, 0x66, 0xa3, 0x1d, 0xd4, 0x1d, 0x97, 0xa7, 0x0a,
	0x85, 0x79, 0x3a, 0xca, 0x35, 0x9e, 0x09, 0xf2, 0xdd, 0x80, 0x7b, 0xf3, 0x4c, 0x94, 0x55, 0xe2,
	0xea, 0xaa, 0x30, 0xb3, 0xe4, 0xce, 0x5f, 0x12, 0x14, 0xe2, 0x3c, 0x04, 0xbd, 0x0b, 0xe5, 0xc9,
	0x12, 0x5d, 0xfb, 0xe4, 0x58, 0x33, 0x96, 0x0c, 0xb4, 0x0c, 0xc5, 0x25, 0x71, 0xe1, 0x60, 0x15,
	0x09, 0x3d, 0x80, 0xad, 0x25, 0x31, 0x61, 0x5d, 0xf2, 0x75, 0x21, 0x7b, 0x4a, 0x02, 0x3d, 0x84,
	0xed, 0x25, 0x21, 0x33, 0xfd, 0x5f, 0xfe, 0x9e, 0xc9, 0x30, 0x9e, 0x36, 0x7e, 0xbd, 0x28, 0x4a,
	0x6f, 0x2e, 0x8a, 0xd2, 0x1f, 0x17, 0x45, 0xe9, 0x87, 0xcb, 0xe2, 0xca, 0x9b, 0xcb, 0xe2, 0xca,
	0xef, 0x97, 0xc5, 0x95, 0xcf, 0x1f, 0xf7, 0x1c, 0xd6, 0x1f, 0x77, 0xab, 0x96, 0xe7, 0xd6, 0xa8,
	0xe5, 0xb3, 0x01, 0xee, 0xd2, 0x9a, 0xb8, 0xb9, 0xda, 0x84, 0xbd, 0xf2, 0xfc, 0x93, 0xda, 0x19,
	0xff, 0x5c, 0xe0, 0xdf, 0x0a, 0xdd, 0x34, 0xff, 0x0e, 0x78, 0xf2, 0x77, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x55, 0xfd, 0xb3, 0x15, 0x49, 0x0c, 0x00, 0x00,
}

func (this *Params) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Params)
	if !ok {
		that2, ok := that.(Params)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *KeySet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeySet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeySet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreatedHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CreatedHeight))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x42
	}
	if m.Status != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x38
	}
	if len(m.GroupPubkey) > 0 {
		i -= len(m.GroupPubkey)
		copy(dAtA[i:], m.GroupPubkey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.GroupPubkey)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Participants) > 0 {
		for iNdEx := len(m.Participants) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Participants[iNdEx])
			copy(dAtA[i:], m.Participants[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Participants[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.MaxSigners != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxSigners))
		i--
		dAtA[i] = 0x20
	}
	if m.Threshold != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Threshold))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KeyShare) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyShare) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyShare) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EphemeralPubkey) > 0 {
		i -= len(m.EphemeralPubkey)
		copy(dAtA[i:], m.EphemeralPubkey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EphemeralPubkey)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.EncryptedPublicShares) > 0 {
		i -= len(m.EncryptedPublicShares)
		copy(dAtA[i:], m.EncryptedPublicShares)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EncryptedPublicShares)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.EncryptedSecretShare) > 0 {
		i -= len(m.EncryptedSecretShare)
		copy(dAtA[i:], m.EncryptedSecretShare)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EncryptedSecretShare)))
		i--
		dAtA[i] = 0x32
	}
	if m.CreatedHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CreatedHeight))
		i--
		dAtA[i] = 0x28
	}
	if len(m.GroupPubkey) > 0 {
		i -= len(m.GroupPubkey)
		copy(dAtA[i:], m.GroupPubkey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.GroupPubkey)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ShareData) > 0 {
		i -= len(m.ShareData)
		copy(dAtA[i:], m.ShareData)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ShareData)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.KeySetId) > 0 {
		i -= len(m.KeySetId)
		copy(dAtA[i:], m.KeySetId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.KeySetId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DKGSession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DKGSession) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DKGSession) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TimeoutHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TimeoutHeight))
		i--
		dAtA[i] = 0x40
	}
	if m.StartHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.StartHeight))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Participants) > 0 {
		for iNdEx := len(m.Participants) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Participants[iNdEx])
			copy(dAtA[i:], m.Participants[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Participants[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.MaxSigners != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxSigners))
		i--
		dAtA[i] = 0x28
	}
	if m.Threshold != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Threshold))
		i--
		dAtA[i] = 0x20
	}
	if m.State != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x18
	}
	if len(m.KeySetId) > 0 {
		i -= len(m.KeySetId)
		copy(dAtA[i:], m.KeySetId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.KeySetId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DKGRound1Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DKGRound1Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DKGRound1Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SubmittedHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SubmittedHeight))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Commitment) > 0 {
		i -= len(m.Commitment)
		copy(dAtA[i:], m.Commitment)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Commitment)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DKGRound2Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DKGRound2Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DKGRound2Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SubmittedHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SubmittedHeight))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Share) > 0 {
		i -= len(m.Share)
		copy(dAtA[i:], m.Share)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Share)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DKGKeySubmission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DKGKeySubmission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DKGKeySubmission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SubmittedHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SubmittedHeight))
		i--
		dAtA[i] = 0x28
	}
	if len(m.EphemeralPubkey) > 0 {
		i -= len(m.EphemeralPubkey)
		copy(dAtA[i:], m.EphemeralPubkey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EphemeralPubkey)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.EncryptedPublicShares) > 0 {
		i -= len(m.EncryptedPublicShares)
		copy(dAtA[i:], m.EncryptedPublicShares)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EncryptedPublicShares)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.EncryptedSecretShare) > 0 {
		i -= len(m.EncryptedSecretShare)
		copy(dAtA[i:], m.EncryptedSecretShare)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EncryptedSecretShare)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SigningRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SigningRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SigningRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreatedHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CreatedHeight))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Status != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Callback) > 0 {
		i -= len(m.Callback)
		copy(dAtA[i:], m.Callback)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Callback)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.MessageHash) > 0 {
		i -= len(m.MessageHash)
		copy(dAtA[i:], m.MessageHash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.MessageHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Requester) > 0 {
		i -= len(m.Requester)
		copy(dAtA[i:], m.Requester)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Requester)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.KeySetId) > 0 {
		i -= len(m.KeySetId)
		copy(dAtA[i:], m.KeySetId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.KeySetId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SigningSession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SigningSession) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SigningSession) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TimeoutHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TimeoutHeight))
		i--
		dAtA[i] = 0x38
	}
	if m.StartHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.StartHeight))
		i--
		dAtA[i] = 0x30
	}
	if m.State != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Participants) > 0 {
		for iNdEx := len(m.Participants) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Participants[iNdEx])
			copy(dAtA[i:], m.Participants[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Participants[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Threshold != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Threshold))
		i--
		dAtA[i] = 0x18
	}
	if len(m.KeySetId) > 0 {
		i -= len(m.KeySetId)
		copy(dAtA[i:], m.KeySetId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.KeySetId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RequestId) > 0 {
		i -= len(m.RequestId)
		copy(dAtA[i:], m.RequestId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RequestId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SigningCommitment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SigningCommitment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SigningCommitment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SubmittedHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SubmittedHeight))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Commitment) > 0 {
		i -= len(m.Commitment)
		copy(dAtA[i:], m.Commitment)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Commitment)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignatureShare) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignatureShare) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignatureShare) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SubmittedHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SubmittedHeight))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Share) > 0 {
		i -= len(m.Share)
		copy(dAtA[i:], m.Share)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Share)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *KeySet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Threshold != 0 {
		n += 1 + sovTypes(uint64(m.Threshold))
	}
	if m.MaxSigners != 0 {
		n += 1 + sovTypes(uint64(m.MaxSigners))
	}
	if len(m.Participants) > 0 {
		for _, s := range m.Participants {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.GroupPubkey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovTypes(uint64(m.Status))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CreatedHeight != 0 {
		n += 1 + sovTypes(uint64(m.CreatedHeight))
	}
	return n
}

func (m *KeyShare) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KeySetId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ShareData)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.GroupPubkey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CreatedHeight != 0 {
		n += 1 + sovTypes(uint64(m.CreatedHeight))
	}
	l = len(m.EncryptedSecretShare)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.EncryptedPublicShares)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.EphemeralPubkey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *DKGSession) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.KeySetId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovTypes(uint64(m.State))
	}
	if m.Threshold != 0 {
		n += 1 + sovTypes(uint64(m.Threshold))
	}
	if m.MaxSigners != 0 {
		n += 1 + sovTypes(uint64(m.MaxSigners))
	}
	if len(m.Participants) > 0 {
		for _, s := range m.Participants {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.StartHeight != 0 {
		n += 1 + sovTypes(uint64(m.StartHeight))
	}
	if m.TimeoutHeight != 0 {
		n += 1 + sovTypes(uint64(m.TimeoutHeight))
	}
	return n
}

func (m *DKGRound1Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Commitment)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SubmittedHeight != 0 {
		n += 1 + sovTypes(uint64(m.SubmittedHeight))
	}
	return n
}

func (m *DKGRound2Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Share)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SubmittedHeight != 0 {
		n += 1 + sovTypes(uint64(m.SubmittedHeight))
	}
	return n
}

func (m *DKGKeySubmission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.EncryptedSecretShare)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.EncryptedPublicShares)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.EphemeralPubkey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SubmittedHeight != 0 {
		n += 1 + sovTypes(uint64(m.SubmittedHeight))
	}
	return n
}

func (m *SigningRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.KeySetId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Requester)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.MessageHash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Callback)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovTypes(uint64(m.Status))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CreatedHeight != 0 {
		n += 1 + sovTypes(uint64(m.CreatedHeight))
	}
	return n
}

func (m *SigningSession) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.KeySetId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Threshold != 0 {
		n += 1 + sovTypes(uint64(m.Threshold))
	}
	if len(m.Participants) > 0 {
		for _, s := range m.Participants {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.State != 0 {
		n += 1 + sovTypes(uint64(m.State))
	}
	if m.StartHeight != 0 {
		n += 1 + sovTypes(uint64(m.StartHeight))
	}
	if m.TimeoutHeight != 0 {
		n += 1 + sovTypes(uint64(m.TimeoutHeight))
	}
	return n
}

func (m *SigningCommitment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Commitment)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SubmittedHeight != 0 {
		n += 1 + sovTypes(uint64(m.SubmittedHeight))
	}
	return n
}

func (m *SignatureShare) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Share)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SubmittedHeight != 0 {
		n += 1 + sovTypes(uint64(m.SubmittedHeight))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeySet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeySet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeySet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			m.Threshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Threshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSigners", wireType)
			}
			m.MaxSigners = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSigners |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Participants", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Participants = append(m.Participants, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupPubkey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupPubkey = append(m.GroupPubkey[:0], dAtA[iNdEx:postIndex]...)
			if m.GroupPubkey == nil {
				m.GroupPubkey = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= KeySetStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedHeight", wireType)
			}
			m.CreatedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyShare) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyShare: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyShare: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeySetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeySetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShareData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShareData = append(m.ShareData[:0], dAtA[iNdEx:postIndex]...)
			if m.ShareData == nil {
				m.ShareData = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupPubkey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupPubkey = append(m.GroupPubkey[:0], dAtA[iNdEx:postIndex]...)
			if m.GroupPubkey == nil {
				m.GroupPubkey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedHeight", wireType)
			}
			m.CreatedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedSecretShare", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedSecretShare = append(m.EncryptedSecretShare[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedSecretShare == nil {
				m.EncryptedSecretShare = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedPublicShares", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedPublicShares = append(m.EncryptedPublicShares[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedPublicShares == nil {
				m.EncryptedPublicShares = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EphemeralPubkey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EphemeralPubkey = append(m.EphemeralPubkey[:0], dAtA[iNdEx:postIndex]...)
			if m.EphemeralPubkey == nil {
				m.EphemeralPubkey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DKGSession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DKGSession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DKGSession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeySetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeySetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= DKGState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			m.Threshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Threshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSigners", wireType)
			}
			m.MaxSigners = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSigners |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Participants", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Participants = append(m.Participants, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartHeight", wireType)
			}
			m.StartHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutHeight", wireType)
			}
			m.TimeoutHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DKGRound1Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DKGRound1Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DKGRound1Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commitment", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commitment = append(m.Commitment[:0], dAtA[iNdEx:postIndex]...)
			if m.Commitment == nil {
				m.Commitment = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmittedHeight", wireType)
			}
			m.SubmittedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubmittedHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DKGRound2Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DKGRound2Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DKGRound2Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Share", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Share = append(m.Share[:0], dAtA[iNdEx:postIndex]...)
			if m.Share == nil {
				m.Share = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmittedHeight", wireType)
			}
			m.SubmittedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubmittedHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DKGKeySubmission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DKGKeySubmission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DKGKeySubmission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedSecretShare", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedSecretShare = append(m.EncryptedSecretShare[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedSecretShare == nil {
				m.EncryptedSecretShare = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedPublicShares", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedPublicShares = append(m.EncryptedPublicShares[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedPublicShares == nil {
				m.EncryptedPublicShares = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EphemeralPubkey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EphemeralPubkey = append(m.EphemeralPubkey[:0], dAtA[iNdEx:postIndex]...)
			if m.EphemeralPubkey == nil {
				m.EphemeralPubkey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmittedHeight", wireType)
			}
			m.SubmittedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubmittedHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SigningRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SigningRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SigningRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeySetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeySetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requester", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requester = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageHash = append(m.MessageHash[:0], dAtA[iNdEx:postIndex]...)
			if m.MessageHash == nil {
				m.MessageHash = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Callback", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Callback = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= SigningRequestStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedHeight", wireType)
			}
			m.CreatedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SigningSession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SigningSession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SigningSession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeySetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeySetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			m.Threshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Threshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Participants", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Participants = append(m.Participants, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= SigningState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartHeight", wireType)
			}
			m.StartHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutHeight", wireType)
			}
			m.TimeoutHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SigningCommitment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SigningCommitment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SigningCommitment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commitment", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commitment = append(m.Commitment[:0], dAtA[iNdEx:postIndex]...)
			if m.Commitment == nil {
				m.Commitment = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmittedHeight", wireType)
			}
			m.SubmittedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubmittedHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignatureShare) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignatureShare: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignatureShare: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Share", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Share = append(m.Share[:0], dAtA[iNdEx:postIndex]...)
			if m.Share == nil {
				m.Share = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmittedHeight", wireType)
			}
			m.SubmittedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubmittedHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
